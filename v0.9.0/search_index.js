var documenterSearchIndex = {"docs":
[{"location":"manual/plotting/#Analysis-and-plotting","page":"Analysis and plotting","title":"Analysis and plotting","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"The key method for visualization is transform_solutions, which parses a string into a symbolic expression and evaluates it for every steady state solution. ","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.transform_solutions","category":"page"},{"location":"manual/plotting/#HarmonicBalance.transform_solutions","page":"Analysis and plotting","title":"HarmonicBalance.transform_solutions","text":"transform_solutions(res::Result, func; branches) -> Vector\n\n\nTakes a Result object and a string f representing a Symbolics.jl expression. Returns an array with the values of f evaluated for the respective solutions. Additional substitution rules can be specified in rules in the format (\"a\" => val) or (a => val)\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#Plotting-solutions","page":"Analysis and plotting","title":"Plotting solutions","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"The function plot is multiple-dispatched to plot 1D and 2D datasets.  In 1D, the solutions are colour-coded according to the branches obtained by sort_solutions. ","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.plot(::Result, varags...)","category":"page"},{"location":"manual/plotting/#RecipesBase.plot-Tuple{Result, Vararg{Any}}","page":"Analysis and plotting","title":"RecipesBase.plot","text":"plot(res::Result, varargs...; cut, kwargs...) -> Plots.Plot\n\n\nPlot a Result object.\n\nClass selection done by passing String or Vector{String} as kwarg:\n\nclass       :   only plot solutions in this class(es) (\"all\" --> plot everything)\nnot_class   :   do not plot solutions in this class(es)\n\nOther kwargs are passed onto Plots.gr().\n\nSee also plot!\n\nThe x,y,z arguments are Strings compatible with Symbolics.jl, e.g., y=2*sqrt(u1^2+v1^2) plots the amplitude of the first quadratures multiplied by 2.\n\n1D plots\n\nplot(res::Result; x::String, y::String, class=\"default\", not_class=[], kwargs...)\nplot(res::Result, y::String; kwargs...) # take x automatically from Result\n\nDefault behaviour is to plot stable solutions as full lines, unstable as dashed.\n\nIf a sweep in two parameters were done, i.e., dim(res)==2, a one dimensional cut can be plotted by using the keyword cut were it takes a Pair{Num, Float64} type entry. For example, plot(res, y=\"sqrt(u1^2+v1^2), cut=(λ => 0.2)) plots a cut at λ = 0.2.\n\n\n\n2D plots\n\nplot(res::Result; z::String, branch::Int64, class=\"physical\", not_class=[], kwargs...)\n\nTo make the 2d plot less chaotic it is required to specify the specific branch to plot, labeled by a Int64.\n\nThe x and y axes are taken automatically from res\n\n\n\n\n\n","category":"method"},{"location":"manual/plotting/#Plotting-phase-diagrams","page":"Analysis and plotting","title":"Plotting phase diagrams","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"In many problems, rather than in any property of the solutions themselves, we are interested in the phase diagrams, encoding the number of (stable) solutions in different regions of the parameter space. plot_phase_diagram handles this for 1D and 2D datasets.","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.plot_phase_diagram","category":"page"},{"location":"manual/plotting/#HarmonicBalance.plot_phase_diagram","page":"Analysis and plotting","title":"HarmonicBalance.plot_phase_diagram","text":"plot_phase_diagram(res::Result; kwargs...) -> Plots.Plot\n\n\nPlot the number of solutions in a Result object as a function of the parameters. Works with 1D and 2D datasets.\n\nClass selection done by passing String or Vector{String} as kwarg:\n\nclass::String       :   only count solutions in this class (\"all\" --> plot everything)\nnot_class::String   :   do not count solutions in this class\n\nOther kwargs are passed onto Plots.gr()\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#Plot-spaghetti-plot","page":"Analysis and plotting","title":"Plot spaghetti plot","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"Sometimes, it is useful to plot the quadratures of the steady states (u, v) in function of a swept parameter. This is done with plot_spaghetti.","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.plot_spaghetti","category":"page"},{"location":"manual/plotting/#HarmonicBalance.plot_spaghetti","page":"Analysis and plotting","title":"HarmonicBalance.plot_spaghetti","text":"plot_spaghetti(res::Result; x, y, z, kwargs...)\n\nPlot a three dimension line plot of a Result object as a function of the parameters. Works with 1D and 2D datasets.\n\nClass selection done by passing String or Vector{String} as kwarg:\n\nclass::String       :   only count solutions in this class (\"all\" --> plot everything)\nnot_class::String   :   do not count solutions in this class\n\nOther kwargs are passed onto Plots.gr()\n\n\n\n\n\n","category":"function"},{"location":"examples/simple_Duffing/#Duffing","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"","category":"section"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Here we show the workflow of HarmonicBalance.jl on a simple example - the driven Duffing oscillator. The code is also available as a Jupyter notebook. ","category":"page"},{"location":"examples/simple_Duffing/#The-equations","page":"Introduction: the Duffing oscillator","title":"The equations","text":"","category":"section"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The equation of motion for the displacement x(t) reads","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"beginequation labeleqduffing\nunderbraceddotx(t) + gamma dotx(t) + omega_0^2 x(t)_textdamped harmonic oscillator + underbracealpha x(t)^3_textDuffing coefficient = underbraceF cos(omega t)_textperiodic drive\nendequation","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"For alpha=0, the system becomes linear and responds precisely at the drive frequency, so that x(t) = X cos(omega t + phi), where X and phi can be found analytically. For alpha neq 0 this is no longer possible. ","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"We can obtain some intuition by treating alpha perturbatively, i.e., by solving","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"ddotx(t) + gamma dotx(t) + omega_0^2 x(t) + epsilon alpha x(t)^3 = F cos(omega t)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"for small epsilon. To zeroth order, the response of the system is x_0(t) = X_0 cos(omega t + phi_0). Expanding x(t) = x_0(t) + epsilon x_1(t), we find that the perturbation x_1(t) satisfies to first order","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"ddotx_1(t) + gamma dotx_1(t) left omega_0^2 + frac3 alpha X_0^24 right x_1(t) = - fracalpha X_0^34 cos(3 omega t + 3 phi_0) ","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"which gives a response of the form x_1(t) = X_1 cos(3 omega t + phi_1). Clearly, the oscillator now responds not only at frequency omega, but also at 3 omega! This effect is known as high harmonic generation or more generally frequency conversion. By continuing the procedure to higher orders, we eventually obtain an infinity of harmonics present in the response. In general, there is no analytical solution to such problems.","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Fortunately, some harmonics are more important than others. By truncating the infinite-dimensional Fourier space to a set of judiciously chosen harmonics, we may obtain a soluble system. For the Duffing resonator, we can well try to only consider the drive frequency omega. To implement this, we use the harmonic ansatz","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"x(t) = U cos(omega t) + V sin(omega t) ","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"which constraints the spectrum of x(t) to a single harmonic. Fixing the quadratures U and V to be constant then reduces the differential equation \\eqref{eq:duffing} to two coupled cubic polynomial equations (for more details on this step, see the appendices in https://scipost.org/SciPostPhysCodeb.6). Finding the roots of coupled polynomials is in general very hard. We here apply the method of homotopy continuation, as implemented in HomotopyContinuation.jl which is guaranteed to find the complete set of roots.","category":"page"},{"location":"examples/simple_Duffing/#The-code","page":"Introduction: the Duffing oscillator","title":"The code","text":"","category":"section"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"First we need to declare the symbolic variables (the excellent Symbolics.jl is used here).","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"using HarmonicBalance\n@variables α, ω, ω0, F, t, γ, x(t) # declare constant variables and a function x(t)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Next, we have to input Eq.\\eqref{eq:duffing}. This will be stored as a DifferentialEquation. The input needs to specify that only x is a mathematical variable, the other symbols are parameters:","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"diff_eq = DifferentialEquation(d(x,t,2) + ω0^2*x + α*x^3 + γ*d(x,t) ~ F*cos(ω*t), x)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The harmonic ansatz needs to be specified now – we expand x in a single frequency omega.","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"add_harmonic!(diff_eq, x, ω) # specify the ansatz x = u(T) cos(ωt) + v(T) sin(ωt)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The object diff_eq now contains all the necessary information","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"System of 1 differential equations\nVariables:       x(t)\nHarmonic ansatz: x(t) => ω;   \n\nα*(x(t)^3) + (ω0^2)*x(t) + γ*Differential(t)(x(t)) + Differential(t)(Differential(t)(x(t))) ~ F*cos(t*ω)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"We are ready to start plugging in numbers and solving! First we convert the differential equation to the algebraic harmonic equations (coupled polynomials in U and V). ","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"harmonic_eq = get_harmonic_equations(diff_eq)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The resulting object shows:","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"A set of 2 harmonic equations\nVariables: u1(T), v1(T)\nParameters: α, ω, γ, ω0, F\n\nHarmonic ansatz: \nx(t) = u1*cos(ωt) + v1*sin(ωt)\n\nHarmonic equations:\n\nγ*Differential(T)(u1(T)) + (ω0^2)*u1(T) + (3//4)*α*(u1(T)^3) + γ*ω*v1(T) + (2//1)*ω*Differential(T)(v1(T)) + (3//4)*α*(v1(T)^2)*u1(T) - (ω^2)*u1(T) ~ F\n\n(ω0^2)*v1(T) + γ*Differential(T)(v1(T)) + (3//4)*α*(v1(T)^3) + (3//4)*α*(u1(T)^2)*v1(T) - (ω^2)*v1(T) - (2//1)*ω*Differential(T)(u1(T)) - γ*ω*u1(T) ~ 0","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The variables u1 and v1 were declared automatically to construct the harmonic ansatz. The slow time variable T describes variation of the quadratures on timescales much slower than ω. For a steady state, all derivatives w.r.t T vanish, leaving only algebraic equations to be solved. ","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Let us now find steady states by solving harmonic_eq for numerical parameters. Homotopy continuation is especially suited to solving over a range of parameter values. Here we will solve over a range of driving frequencies ω – these are stored as {Sym, Vector{Float64}} or {Sym, LinRange}:","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"varied = ω => LinRange(0.9, 1.2, 100) # range of parameter values","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The other parameters we be fixed – these are declared as {Sym, Float64} pairs:","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"fixed = (α => 1., ω0 => 1.0, F => 0.01, γ=>0.01) # fixed parameters","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Now everything is ready to crank the handle. get_steady_states solves our harmonic_eq using the varied and fixed parameters:","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"result = get_steady_states(harmonic_eq, varied, fixed)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The results are shown:","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"A steady state result for 100 parameter points\n\nSolution branches:   3\n   of which real:    3\n   of which stable:  2\n\nClasses: stable, physical, Hopf, binary_labels","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The algorithm has found 3 solution branches in total (out of the hypothetically admissible 3^2 = 9). All of these are real – and thefore physically observable – for at least some values of omega. Only 2 branches are stable under infinitesimal perturbations.","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The \"Classes\" are boolean labels classifying each solution point, which may be used to select results for plotting. # hide","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"We now want to visualize the results. Here we plot the solution amplitude, sqrtU^2 + V^2 against the drive frequency omega: ","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"plot(result, \"sqrt(u1^2 + v1^2)\")","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/simple_Duffing/response_single.png\" alignment=\"center\" \\>","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"⠀","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"This is the expected response curve for the Duffing equation.","category":"page"},{"location":"examples/simple_Duffing/#Advanced:-using-multiple-harmonics","page":"Introduction: the Duffing oscillator","title":"Advanced: using multiple harmonics","text":"","category":"section"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"In the above example, we truncated the Fourier space to a single harmonic omega – the oscillator was assumed to only oscillate at the drive frequency. We however also argued that frequency conversion takes place, to first order from omega to 3 omega. We can reflect this process by using a larger harmonic ansatz:","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"beginequation\nx(t) = U_1 cos(omega t) + V_1 sin(omega t) + U_2 cos(3omega t) + V_2 sin(3omega t) \nendequation","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Note that this is not a perturbative treatment! The harmonics omega and 3 omega are on the same footing here. This is implemented as","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"add_harmonic!(diff_eq, x, [ω, 3ω]) # specify the two-harmonics ansatz\nharmonic_eq = get_harmonic_equations(diff_eq)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"A set of 4 harmonic equations\nVariables: u1(T), v1(T), u2(T), v2(T)\nParameters: ω, ω0, α, γ, F\n\nHarmonic ansatz: \nx(t) = u1*cos(ωt) + v1*sin(ωt) + u2*cos(3ωt) + v2*sin(3ωt)\n\nHarmonic equations:\n\n(ω0^2)*u1(T) + γ*Differential(T)(u1(T)) + (3//4)*α*(u1(T)^3) + γ*ω*v1(T) + (2//1)*ω*Differential(T)(v1(T)) + (3//2)*α*(u2(T)^2)*u1(T) + (3//4)*α*(u1(T)^2)*u2(T) + (3//4)*α*(v1(T)^2)*u1(T) + (3//2)*α*(v2(T)^2)*u1(T) + (3//2)*α*u1(T)*v1(T)*v2(T) - (ω^2)*u1(T) - (3//4)*α*(v1(T)^2)*u2(T) ~ F\n\nγ*Differential(T)(v1(T)) + (ω0^2)*v1(T) + (3//4)*α*(v1(T)^3) + (3//4)*α*(u1(T)^2)*v1(T) + (3//2)*α*(u2(T)^2)*v1(T) + (3//2)*α*(v2(T)^2)*v1(T) + (3//4)*α*(u1(T)^2)*v2(T) - (ω^2)*v1(T) - (2//1)*ω*Differential(T)(u1(T)) - γ*ω*u1(T) - (3//4)*α*(v1(T)^2)*v2(T) - (3//2)*α*u1(T)*u2(T)*v1(T) ~ 0\n\n(ω0^2)*u2(T) + γ*Differential(T)(u2(T)) + (1//4)*α*(u1(T)^3) + (3//4)*α*(u2(T)^3) + (6//1)*ω*Differential(T)(v2(T)) + (3//2)*α*(u1(T)^2)*u2(T) + (3//4)*α*(v2(T)^2)*u2(T) + (3//2)*α*(v1(T)^2)*u2(T) + (3//1)*γ*ω*v2(T) - (9//1)*(ω^2)*u2(T) - (3//4)*α*(v1(T)^2)*u1(T) ~ 0\n\nγ*Differential(T)(v2(T)) + (ω0^2)*v2(T) + (3//4)*α*(v2(T)^3) + (3//4)*α*(u1(T)^2)*v1(T) + (3//4)*α*(u2(T)^2)*v2(T) + (3//2)*α*(u1(T)^2)*v2(T) + (3//2)*α*(v1(T)^2)*v2(T) - (1//4)*α*(v1(T)^3) - (9//1)*(ω^2)*v2(T) - (6//1)*ω*Differential(T)(u2(T)) - (3//1)*γ*ω*u2(T) ~ 0\n","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The variables u1,v1 now encode ω and u2, v2 encode 3ω. We see this system is much harder to solve as we now have 4 harmonic variables, resulting in 4 coupled cubic equations. A maximum of 3^4 = 81 solutions may appear! ","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"For the above parameters (where a perturbative treatment would have been reasonable), the principal response at omega looks rather similar, with a much smaller upconverted component appearing at 3 omega: (Image: fig2)","category":"page"},{"location":"examples/simple_Duffing/#Non-perturbative-results-(strong-interactions)","page":"Introduction: the Duffing oscillator","title":"Non-perturbative results (strong interactions)","text":"","category":"section"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The non-perturbative nature of Eq.(3) allows us to capture some behaviour which is not a mere extension of the usual single-harmonic Duffing response. Suppose we drive a strongly nonlinear resonator at frequency omega cong omega_0  3. Such a drive is far out of resonance, however, the upconverted harmonic 3 omega = omega_0 is not and may play an important role! Let us try this out:","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"fixed = (α => 10., ω0 => 3, F => 5, γ=>0.01)   # fixed parameters\nvaried = ω => LinRange(0.9, 1.4, 100)           # range of parameter values\nresult = get_steady_states(harmonic_eq, varied, fixed)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"A steady state result for 100 parameter points\n\nSolution branches:   9\n   of which real:    3\n   of which stable:  2\n\nClasses: stable, physical, Hopf, binary_labels","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Although 9 branches were found in total, only 3 remain physical (real-valued). Let us visualise the amplitudes corresponding to the two harmonics, sqrtU_1^2 + V_1^2 and sqrtU_2^2 + V_2^2 :","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"p1 = plot(result, \"sqrt(u1^2 + v1^2)\", legend=false)\np2 = plot(result, \"sqrt(u2^2 + v2^2)\")\nplot(p1, p2)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"(Image: fig3)","category":"page"},{"location":"examples/simple_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The contributions of omega and 3omega are now comparable and the system shows some fairly complex behaviour! This demonstrates how an exact solution within an extended Fourier subspace [Eq. (3)] goes beyond a perturbative treatment.","category":"page"},{"location":"manual/entering_eom/#Entering-equations-of-motion","page":"Entering equations of motion","title":"Entering equations of motion","text":"","category":"section"},{"location":"manual/entering_eom/","page":"Entering equations of motion","title":"Entering equations of motion","text":"The struct DifferentialEquation is the primary input method; it holds an ODE or a coupled system of ODEs composed of terms with harmonic time-dependence The dependent variables are specified during input, any other symbols are identified as parameters. Information on which variable is to be expanded in which harmonic is specified using add_harmonic!. ","category":"page"},{"location":"manual/entering_eom/","page":"Entering equations of motion","title":"Entering equations of motion","text":"DifferentialEquation.equations stores a dictionary assigning variables to equations. This information is necessary because the harmonics belonging to a variable are later used to Fourier-transform its corresponding ODE.","category":"page"},{"location":"manual/entering_eom/","page":"Entering equations of motion","title":"Entering equations of motion","text":"DifferentialEquation\nadd_harmonic!\nget_variables(::DifferentialEquation)\nget_independent_variables(::DifferentialEquation)","category":"page"},{"location":"manual/entering_eom/#HarmonicBalance.DifferentialEquation","page":"Entering equations of motion","title":"HarmonicBalance.DifferentialEquation","text":"mutable struct DifferentialEquation\n\nHolds differential equation(s) of motion and a set of harmonics to expand each variable. This is the primary input for HarmonicBalance.jl ; after inputting the equations, the harmonics     ansatz needs to be specified using add_harmonic!.\n\nFields\n\nequations::OrderedCollections.OrderedDict{Symbolics.Num, Symbolics.Equation}: Assigns to each variable an equation of motion.\nharmonics::OrderedCollections.OrderedDict{Symbolics.Num, OrderedCollections.OrderedSet{Symbolics.Num}}: Assigns to each variable a set of harmonics.\n\nExample\n\njulia> @variables t, x(t), y(t), ω0, ω, F, k;\n\n# equivalent ways to enter the simple harmonic oscillator\njulia> DifferentialEquation(d(x,t,2) + ω0^2 * x - F * cos(ω*t), x);\njulia> DifferentialEquation(d(x,t,2) + ω0^2 * x ~ F * cos(ω*t), x);\n\n# two coupled oscillators, one of them driven\njulia> DifferentialEquation([d(x,t,2) + ω0^2 * x - k*y, d(y,t,2) + ω0^2 * y - k*x] .~ [F * cos(ω*t), 0], [x,y]);\n\n\n\n\n\n","category":"type"},{"location":"manual/entering_eom/#HarmonicBalance.add_harmonic!","page":"Entering equations of motion","title":"HarmonicBalance.add_harmonic!","text":"add_harmonic!(\n    diff_eom::DifferentialEquation,\n    var::Symbolics.Num,\n    ω\n) -> DifferentialEquation\n\n\nAdd the harmonic ω to the harmonic ansatz used to expand the variable var in diff_eom.\n\nExample\n\ndefine the simple harmonic oscillator and specify that x(t) oscillates with frequency ω\n\njulia> @variables t, x(t), y(t), ω0, ω, F, k;\njulia> diff_eq = DifferentialEquation(d(x,t,2) + ω0^2 * x ~ F * cos(ω*t), x);\njulia> add_harmonic!(diff_eq, x, ω) # expand x using ω\n\nSystem of 1 differential equations\nVariables:       x(t)\nHarmonic ansatz: x(t) => ω;\n\n(ω0^2)*x(t) + Differential(t)(Differential(t)(x(t))) ~ F*cos(t*ω)\n\n\n\n\n\n","category":"function"},{"location":"manual/entering_eom/#Symbolics.get_variables-Tuple{DifferentialEquation}","page":"Entering equations of motion","title":"Symbolics.get_variables","text":"get_variables(\n    diff_eom::DifferentialEquation\n) -> Vector{Symbolics.Num}\n\n\nReturn the dependent variables of diff_eom.\n\n\n\n\n\n","category":"method"},{"location":"manual/entering_eom/#HarmonicBalance.get_independent_variables-Tuple{DifferentialEquation}","page":"Entering equations of motion","title":"HarmonicBalance.get_independent_variables","text":"get_independent_variables(\n    diff_eom::DifferentialEquation\n) -> Any\n\n\nReturn the independent dependent variables of diff_eom.\n\n\n\n\n\n","category":"method"},{"location":"manual/time_dependent/#Time-evolution","page":"Time evolution","title":"Time evolution","text":"","category":"section"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"Generally, solving the ODE of oscillatory systems in time requires numerically tracking the oscillations. This is a computationally expensive process; however, using the harmonic ansatz removes the oscillatory time-dependence. Simulating instead the harmonic variables of a HarmonicEquation is vastly more efficient - a steady state of the system appears as a fixed point in multidimensional space rather than an oscillatory function.","category":"page"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"The module TimeEvolution is used to interface HarmonicEquation with the powerful solvers contained in DifferentialEquations.jl. Time-dependent parameter sweeps are defined using the object ParameterSweep.","category":"page"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"HarmonicBalance.TimeEvolution.ODEProblem\nHarmonicBalance.TimeEvolution.ParameterSweep","category":"page"},{"location":"manual/time_dependent/#Plotting","page":"Time evolution","title":"Plotting","text":"","category":"section"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"HarmonicBalance.TimeEvolution.plot(::HarmonicBalance.TimeEvolution.OrdinaryDiffEq.ODESolution, ::Any, ::HarmonicEquation)","category":"page"},{"location":"manual/time_dependent/#Miscellaneous","page":"Time evolution","title":"Miscellaneous","text":"","category":"section"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"Using a time-dependent simulation can verify solution stability in cases where the Jacobian is too expensive to compute.","category":"page"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"HarmonicBalance.TimeEvolution.is_stable","category":"page"},{"location":"background/limit_cycles/#limit_cycles_bg","page":"Limit cycles","title":"Limit cycles","text":"","category":"section"},{"location":"background/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"Under construction, see Chapter 6 in Jan's thesis or our recent paper.","category":"page"},{"location":"background/limit_cycles/#gauge_fixing","page":"Limit cycles","title":"Gauge fixing","text":"","category":"section"},{"location":"background/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"Thesis Eq. (6.14), (6.15).","category":"page"},{"location":"background/limit_cycles/#degeneracies","page":"Limit cycles","title":"Degeneracies","text":"","category":"section"},{"location":"background/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"Thesis p. 74. Provided the fixed variable is that corresponding to the lowest subharmonic (i.e., to ω_lc, not 2ω_lc etc.), the degeneracy is always fourfold.","category":"page"},{"location":"manual/extracting_harmonics/#Extracting-harmonic-equations","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"","category":"section"},{"location":"manual/extracting_harmonics/#Harmonic-Balance-method","page":"Extracting harmonic equations","title":"Harmonic Balance method","text":"","category":"section"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"Once a DifferentialEquation is defined and its harmonics specified, one can extract the harmonic equations using get_harmonic_equations, which itself is composed of the subroutines harmonic_ansatz, slow_flow, fourier_transform! and drop_powers. ","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"The harmonic equations use an additional time variable specified as slow_time in get_harmonic_equations. This is essentially a label distinguishing the time dependence of the harmonic variables (expected to be slow) from that of the oscillating terms (expeted to be fast). When the equations are Fourier-transformed to remove oscillating terms, slow_time is treated as a constant. Such an approach is exact when looking for steady states. ","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"get_harmonic_equations\nHarmonicBalance.harmonic_ansatz\nHarmonicBalance.slow_flow\nHarmonicBalance.fourier_transform\nHarmonicBalance.drop_powers","category":"page"},{"location":"manual/extracting_harmonics/#HarmonicBalance.get_harmonic_equations","page":"Extracting harmonic equations","title":"HarmonicBalance.get_harmonic_equations","text":"get_harmonic_equations(diff_eom::DifferentialEquation; fast_time=nothing, slow_time=nothing)\n\nApply the harmonic ansatz, followed by the slow-flow, Fourier transform and dropping higher-order derivatives to obtain a set of ODEs (the harmonic equations) governing the harmonics of diff_eom.\n\nThe harmonics evolve in slow_time, the oscillating terms themselves in fast_time. If no input is used, a variable T is defined for slow_time and fast_time is taken as the independent variable of diff_eom.\n\nBy default, all products of order > 1 of slow_time-derivatives are dropped, which means the equations are linear in the time-derivatives.\n\nExample\n\njulia> @variables t, x(t), ω0, ω, F;\n\n# enter the simple harmonic oscillator\njulia> diff_eom = DifferentialEquation( d(x,t,2) + ω0^2 * x ~ F *cos(ω*t), x);\n\n# expand x in the harmonic ω\njulia> add_harmonic!(diff_eom, x, ω);\n\n# get equations for the harmonics evolving in the slow time T\njulia> harmonic_eom = get_harmonic_equations(diff_eom)\n\nA set of 2 harmonic equations\nVariables: u1(T), v1(T)\nParameters: ω0, ω, F\n\nHarmonic ansatz:\nx(t) = u1*cos(ωt) + v1*sin(ωt)\n\nHarmonic equations:\n\n(ω0^2)*u1(T) + (2//1)*ω*Differential(T)(v1(T)) - (ω^2)*u1(T) ~ F\n\n(ω0^2)*v1(T) - (ω^2)*v1(T) - (2//1)*ω*Differential(T)(u1(T)) ~ 0\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.harmonic_ansatz","page":"Extracting harmonic equations","title":"HarmonicBalance.harmonic_ansatz","text":"harmonic_ansatz(eom::DifferentialEquation, time::Num; coordinates=\"Cartesian\")\n\nExpand each variable of diff_eom using the harmonics assigned to it with time as the time variable. For each harmonic of each variable, instance(s) of HarmonicVariable are automatically created and named.\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.slow_flow","page":"Extracting harmonic equations","title":"HarmonicBalance.slow_flow","text":"slow_flow(eom::HarmonicEquation; fast_time::Num, slow_time::Num, degree=2)\n\nRemoves all derivatives w.r.t fast_time (and their products) in eom of power degree. In the remaining derivatives, fast_time is replaced by slow_time.\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.fourier_transform","page":"Extracting harmonic equations","title":"HarmonicBalance.fourier_transform","text":"fourier_transform(\n    eom::HarmonicEquation,\n    time::Symbolics.Num\n) -> HarmonicEquation\n\n\nExtract the Fourier components of eom corresponding to the harmonics specified in eom.variables. For each non-zero harmonic of each variable, 2 equations are generated (cos and sin Fourier coefficients). For each zero (constant) harmonic, 1 equation is generated time does not appear in the resulting equations anymore.\n\nUnderlying assumption: all time-dependences are harmonic.\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.drop_powers","page":"Extracting harmonic equations","title":"HarmonicBalance.drop_powers","text":"drop_powers(expr, vars, deg)\n\n\nRemove parts of expr where the combined power of vars is => deg.\n\nExample\n\njulia> @variables x,y;\njulia>drop_powers((x+y)^2, x, 2)\ny^2 + 2*x*y\njulia>drop_powers((x+y)^2, [x,y], 2)\n0\njulia>drop_powers((x+y)^2 + (x+y)^3, [x,y], 3)\nx^2 + y^2 + 2*x*y\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicVariable-and-HarmonicEquation-types","page":"Extracting harmonic equations","title":"HarmonicVariable and HarmonicEquation types","text":"","category":"section"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"The equations governing the harmonics are stored using the two following structs. When going from the original to the harmonic equations, the harmonic ansatz x_i(t) = sum_j=1^M u_ij  (T)  cos(omega_ij t)+ v_ij(T) sin(omega_ij t) is used. Internally, each pair (u_ij v_ij) is stored as a HarmonicVariable. This includes the identification of omega_ij and x_i(t), which is needed to later reconstruct x_i(t).","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"HarmonicVariable","category":"page"},{"location":"manual/extracting_harmonics/#HarmonicBalance.HarmonicVariable","page":"Extracting harmonic equations","title":"HarmonicBalance.HarmonicVariable","text":"mutable struct HarmonicVariable\n\nHolds a variable stored under symbol describing the harmonic ω of natural_variable.\n\nFields\n\nsymbol::Symbolics.Num: Symbol of the variable in the HarmonicBalance namespace.\nname::String: Human-readable labels of the variable, used for plotting.\ntype::String: Type of the variable (u or v for quadratures, a for a constant, Hopf for Hopf etc.)\nω::Symbolics.Num: The harmonic being described.\nnatural_variable::Symbolics.Num: The natural variable whose harmonic is being described.\n\n\n\n\n\n","category":"type"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"When the full set of equations of motion is expanded using the harmonic ansatz, the result is stored as a HarmonicEquation. For an initial equation of motion consisting of M variables, each expanded in N harmonics, the resulting HarmonicEquation holds 2NM equations of 2NM variables. Each symbol not corresponding to a variable is identified as a parameter. ","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"A HarmonicEquation can be either parsed into a steady-state Problem or solved using a dynamical ODE solver.","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"HarmonicEquation","category":"page"},{"location":"manual/extracting_harmonics/#HarmonicBalance.HarmonicEquation","page":"Extracting harmonic equations","title":"HarmonicBalance.HarmonicEquation","text":"mutable struct HarmonicEquation\n\nHolds a set of algebraic equations governing the harmonics of a DifferentialEquation.\n\nFields\n\nequations::Vector{Symbolics.Equation}: A set of equations governing the harmonics.\nvariables::Vector{HarmonicVariable}: A set of variables describing the harmonics.\nparameters::Vector{Symbolics.Num}: The parameters of the equation set.\nnatural_equation::DifferentialEquation: The natural equation (before the harmonic ansatz was used).\n\n\n\n\n\n","category":"type"},{"location":"manual/saving/#Saving-and-loading","page":"Saving and loading","title":"Saving and loading","text":"","category":"section"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"All of the types native to HarmonicBalance.jl can be saved into a .jld2 file using save and loaded using load. Most of the saving/loading is performed using the package JLD2.jl, with the addition of reinstating the symbolic variables in the HarmonicBalance namespace (needed to parse expressions used in the plotting functions) and recompiling stored functions (needed to evaluate Jacobians). As a consequence, composite objects such as Result can be saved and loaded with no loss of information.","category":"page"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"The function export_csv saves a .csv file which can be plot elsewhere.","category":"page"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"HarmonicBalance.save\nHarmonicBalance.load\nHarmonicBalance.export_csv","category":"page"},{"location":"manual/saving/#HarmonicBalance.save","page":"Saving and loading","title":"HarmonicBalance.save","text":"save(filename, object)\n\n\nSaves object into .jld2 file filename (the suffix is added automatically if not entered). The resulting file contains a dictionary with a single entry.\n\n\n\n\n\n","category":"function"},{"location":"manual/saving/#HarmonicBalance.load","page":"Saving and loading","title":"HarmonicBalance.load","text":"load(filename)\n\n\nLoads an object from filename. For objects containing symbolic expressions such as HarmonicEquation, the symbolic variables are reinstated in the HarmonicBalance namespace.\n\n\n\n\n\n","category":"function"},{"location":"manual/saving/#HarmonicBalance.export_csv","page":"Saving and loading","title":"HarmonicBalance.export_csv","text":"export_csv(filename, res, branch)\n\n\nSaves into filename a specified solution branch of the Result res.\n\n\n\n\n\n","category":"function"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"","category":"page"},{"location":"examples/parametron/#parametron","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"","category":"section"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"One of the most famous effects displaced by nonlinear oscillators is parametric resonance, where the frequency of the linear resonator is modulated in time  Phys. Rev. E 94, 022201 (2016). In the following we analyse this system, governed by the equations","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"ddotx(t)+gammadotx(t)+Omega^2(1-lambdacos(2omega t + psi))x + alpha x^3 +eta x^2 dotx+F_textd(t)=0","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"where for completeness we also considered an external drive term F_textd(t)=Fcos(omega t + theta) and a nonlinear damping term eta x^2 dotx","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"To implement this system in Harmonic Balance, we first import the library ","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"using HarmonicBalance","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"Subsequently, we type define parameters in the problem and the oscillating amplitude function x(t) using the variables macro from Symbolics.jl ","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"@variables Ω, γ, λ, F, x, θ, η, α, ω, ψ, t, x(t)\n\nnatural_equation =  d(d(x,t),t) + γ*d(x,t) + Ω^2*(1-λ*cos(2*ω*t+ψ))*x + α*x^3 + η*d(x,t) * x^2\nforces =  F*cos(ω*t + θ)\ndiff_eq = DifferentialEquation(natural_equation + forces, x)","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"Note that an equation of the form  m ddotx+m omega_0^2left(1-lambda cos (2omega t+psi)right) x+gamma dotx+alpha x^3+eta x^2 dotx=F cos omega t can be brought to dimensionless form by rescaling the units as described in Phys. Rev. E 94, 022201 (2016).","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"We are interested in studying the response of the oscillator to parametric driving and forcing. In particular, we focus on the first parametric resonance of the system, i.e. operating around twice the bare frequency of the undriven oscillator omega while the frequency of the external drive is also omega. For this purpose, we consider a harmonic ansatz which contains a single frequency: x(t)approx ucos(omega t)+vsin(omega t).   In HarmonicBalance, we can do this via add_harmonic command:","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"add_harmonic!(diff_eq, x, ω);","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"and replacing this by the time independent (averaged) equations of motion. This can be simply done by writing","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"harmonic_eq = get_harmonic_equations(diff_eq)","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"The output of these equations are consistent with the result found in the literature. Now we are interested in the linear response spectrum, which we can obtain from the solutions to the averaged equations (rotating frame) as a function of the external drive, after fixing all other parameters in the system. A call to get_steady_states then retrieves all steadystates found allong the sweep employing the homotopy continuation method, which occurs in a complex space (see the nice HomotopyContinuation.jl docs)","category":"page"},{"location":"examples/parametron/#1D-parameters","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"1D parameters","text":"","category":"section"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"We start with a varied set containing one parameter, omega,","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"fixed = (Ω => 1.0, γ => 1E-2, λ => 5E-2, F => 1E-3,  α => 1.0, η=>0.3, θ => 0, ψ => 0)\nvaried = ω => range(0.9, 1.1, 100)\n\nresult = get_steady_states(harmonic_eq, varied, fixed)","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"In get_steady_states, the default keywordrandom_warmup=true initiates the homotopy in a generalised version of the harmonic equations, where parameters become random complex numbers. A parameter homotopy then follows to each of the frequency values omega in sweep. This offers speed-up, but requires to be tested in each scenario againts the option random_warmup=false, which initializes the homotopy in a total degree system (maximum number of roots), but needs to track significantly more homotopy paths and there is slower. The threading keyword enables parallel tracking of homotopy paths, and it's set to false simply because we are using a single core computer for now.","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"After solving the system, we can save the full output of the simulation and the model (e.g. symbolic expressions for the harmonic equations) into a file","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"HarmonicBalance.save(\"parametron_result.jld2\", result);","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"During the execution of get_steady_states, different solution branches are classified by their proximity in complex space, with subsequent filtering of real (physically accceptable solutions). In addition, the stability properties of each steady state is assesed from the eigenvalues of the Jacobian matrix. All this information can be succintly represented in a 1D plot via","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"plot(result, x=\"ω\", y=\"sqrt(u1^2 + v1^2)\")","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"This produces the following figure","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/parametron/response.png\" alignment=\"center\"\\>","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"The user can also introduce custom clases based on parameter conditions via classify_solutions!. Plots can be overlaid and use keywords from Plots,","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"classify_solutions!(result, \"sqrt(u1^2 + v1^2) > 0.1\", \"large\")\nplot(result, \"sqrt(u1^2 + v1^2)\", class=[\"physical\", \"large\"], style=:dash)\nplot!(result, \"sqrt(u1^2 + v1^2)\", not_class=\"large\")","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"This overrides the default plotting style (stable=full, unstable=dashed) to give","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/parametron/classified.png\" alignment=\"center\"\\>","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"Alternatively, we may visualise all underlying solutions, including complex ones,","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"plot(result, \"sqrt(u1^2 + v1^2)\", class=\"all\")","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/parametron/all.png\" alignment=\"center\"\\>","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"⠀","category":"page"},{"location":"examples/parametron/#2D-parameters","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"2D parameters","text":"","category":"section"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"The parametrically driven oscillator boasts a stability diagram called \"Arnold's tongues\" delineating zones where the oscillator is stable from those where it is exponentially unstable (if the nonlinearity was absence).  We can retrieve this diagram by calculating the steady states as a function of external detuning delta=omega_L-omega_0 and the parametric drive strength lambda.","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"To perform a 2D sweep over driving frequency omega and parametric drive strength lambda, we keep fixed from before but include 2 variables in varied","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"varied = (ω => range(0.8, 1.2, 50), λ => range(0.001, 0.6, 50))\nresult_2D = get_steady_states(harmonic_eq, varied, fixed);","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"Now, we count the number of solutions for each point and represent the corresponding phase diagram in parameter space. This is done using plot_phase_diagram. Only counting stable solutions,","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"plot_phase_diagram(result_2D, class=\"stable\")","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/parametron/2d_phase_diagram.png\" alignment=\"center\"\\>","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"⠀","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"In addition to phase diagrams, we can plot functions of the solution. The syntax is identical to 1D plotting. Let us overlay 2 branches into a single plot,","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"# overlay branches with different colors\nplot(result_2D, \"sqrt(u1^2 + v1^2)\", branch=1, class=\"stable\", camera=(60,-40))\nplot!(result_2D, \"sqrt(u1^2 + v1^2)\", branch=2, class=\"stable\", color=:red)","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/parametron/2d_amp.png\" alignment=\"center\" width=\"500px\"\\>","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"⠀","category":"page"},{"location":"examples/parametron/","page":"Parametrically driven Duffing resonator: 1D and 2D plots","title":"Parametrically driven Duffing resonator: 1D and 2D plots","text":"Note that solutions are ordered in parameter space according to their closest neighbors. Plots can again be limited to a given class (e.g stable solutions only) through the keyword argument class.","category":"page"},{"location":"examples/time_dependent/#Introduction:-time-dependent-simulations","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"","category":"section"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Most of HarmonicBalance.jl is focused on finding and analysing the steady states. Such states contain no information about transient behaviour, which is crucial to answer the following.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Given an initial condition, which steady state does the system evolve into?\nHow does the system behave if its parameters are varied in time?","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"It is straightforward to evolve the full equation of motion using an ODE solver. However, tracking oscillatory behaviour is computationally expensive.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"In the background, we showed that nonlinear driven systems may be reduced to harmonic equations","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"beginequation labeleqharmeq\nfracdmathbfu(T)dT  = barmathbfF (mathbfu)\nendequation","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"As long as the chosen harmonics constituting mathbfu(T) capture the system's behaviour, we may numerically evolve  Eq. \\eqref{eq:harmeq} instead of the full problem. Since the components of mathbfu(T) only vary very slowly (and are constant in a steady state), this is usually vastly more efficient than evolving the full problem.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Here we primarily demonstrate on the parametrically driven oscillator. The relevant notebooks may be found in the example repo.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"We start by defining our system.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"using HarmonicBalance\n@variables ω0, γ, λ, F, x, θ, η, α, ω, t, x(t)\n\neq =  d(d(x,t),t) + γ*d(x,t) + ω0^2*(1-λ*cos(2*ω*t))*x + α*x^3 + η*d(x,t)*x^2 ~ F*cos(ω*t+θ)\n\ndiff_eq = DifferentialEquation(eq, x)\nadd_harmonic!(diff_eq, x, ω); # single-frequency ansatz\n\nharmonic_eq = get_harmonic_equations(diff_eq);","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"A set of 2 harmonic equations\nVariables: u1(T), v1(T)\n...","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"The object harmonic_eq encodes Eq. \\eqref{eq:harmeq}.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"We now wish to parse this input into DifferentialEquations.jl and use its powerful ODE solvers. The desired object here is DifferentialEquations.ODEProblem, which is then fed into DifferentialEquations.solve.","category":"page"},{"location":"examples/time_dependent/#Evolving-from-an-initial-condition","page":"Introduction: time-dependent simulations","title":"Evolving from an initial condition","text":"","category":"section"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Given mathbfu(T_0), what is mathbfu(T) at future times?","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"For constant parameters, a HarmonicEquation object can be fed into the constructor of ODEProblem. The syntax is similar to DifferentialEquations.jl :","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"import HarmonicBalance.TimeEvolution: ODEProblem, OrdinaryDiffEq.solve\nx0 = [0.0; 0.] # initial condition\nfixed = (ω0 => 1.0,γ => 1E-2, λ => 5E-2, F => 1E-3,  α => 1., η=>0.3, θ => 0, ω=>1.) # parameter values\n\node_problem = ODEProblem(harmonic_eq, fixed, x0 = x0, timespan = (0,1000))","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"ODEProblem with uType Vector{Float64} and tType Int64. In-place: true\ntimespan: (0, 1000)\nu0: 2-element Vector{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"DifferentialEquations.jl takes it from here - we only need to use solve.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"time_evo = solve(ode_problem, saveat=1.);\nplot(time_evo, [\"u1\", \"v1\"], harmonic_eq)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Running the above code with x0 = [0., 0.] and x0 = [0.2, 0.2] gives the plots","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/time_dependent/evo_to_steady.png\" alignment=\"center\" \\>","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"⠀","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Let us compare this to the steady state diagram.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"varied = ω => LinRange(0.9, 1.1, 100)\nresult = get_steady_states(harmonic_eq, varied, fixed)\nplot(result, \"sqrt(u1^2 + v1^2)\")","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/time_dependent/steady.png\" alignment=\"center\" \\>","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"⠀","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Clearly when evolving from x0 = [0.,0.], the system ends up in the low-amplitude branch 2. With x0 = [0.2, 0.2], the system ends up in branch 3.","category":"page"},{"location":"examples/time_dependent/#Parameter-sweeps","page":"Introduction: time-dependent simulations","title":"Parameter sweeps","text":"","category":"section"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Experimentally, the primary means of exploring the steady state landscape is an adiabatic sweep one or more of the system parameters. This takes the system along a solution branch. If this branch disappears or becomes unstable, a jump occurs.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"The object ParameterSweep specifies a sweep, which is then used as an optional sweep keyword in the ODEProblem constructor.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"sweep = ParameterSweep(ω => (0.9,1.1), (0, 2E4))","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"The sweep linearly interpolates between omega = 09 at time 0 and omega  = 11 at time 2e4. For earlier/later times, omega is constant.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Let us now define a new ODEProblem which incorporates sweep and again use solve:","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"ode_problem = ODEProblem(harmonic_eq, fixed, sweep=sweep, x0=[0.1;0.0], timespan=(0, 2E4))\ntime_evo = solve(ode_problem, saveat=100)\nplot(time_evo, \"sqrt(u1^2 + v1^2)\", harmonic_eq)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/time_dependent/sweep_omega.png\" alignment=\"center\" \\>","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"⠀ We see the system first evolves from the initial condition towards the low-amplitude steady state. The amplitude increases as the sweep proceeds, with a jump occurring around omega = 108 (i.e., time 18000).","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Successive sweeps can be combined,","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"sweep1 = ParameterSweep(ω => [0.95, 1.0], (0, 2E4))\nsweep2 = ParameterSweep(λ => [0.05, 0.01], (2E4, 4E4))\nsweep = sweep1 + sweep2","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"multiple parameters can be swept simultaneously,","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"sweep = ParameterSweep([ω => [0.95;1.0], λ => [5E-2;1E-2]], (0, 2E4))","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"and custom sweep functions may be used.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"ωfunc(t) = cos(t)\nsweep = ParameterSweep(ω => ωfunc)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Either of the above can be fed into ODEProblem and simulated. See here for more examples.","category":"page"},{"location":"examples/time_dependent/#Limit-cycles","page":"Introduction: time-dependent simulations","title":"Limit cycles","text":"","category":"section"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"So far, we have largely focused on finding and analysing steady states, i.e., fixed points of the harmonic equations, which satisfy","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"beginequation labeleqharmeqfull\nfracdmathbfu(T)dT  = barmathbfF (mathbfu) = 0\nendequation","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Fixed points are however merely a subset of possible solutions of Eq. \\eqref{eq:harmeqfull} – strictly speaking, solutions where mathbfu(T) remains time-dependent are allowed. These are quite unusual, since barmathbfF (mathbfu) is by construction time-independent and Eq. \\eqref{eq:harmeqfull} thus possesses continuous time-translation symmetry. The appearance of explicitly time-dependent solutions then consitutes spontaneous time-translation symmetry breaking.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Such solutions, known as limit cycles, typically appear as closed periodic trajectories of the harmonic variables mathbfu(T). The simplest way to numerically characterise them is a time-dependent simulation, using a steady-state diagram as a guide.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Here we reconstruct the results of Zambon et al., Phys Rev. A 102, 023526 (2020), where limit cycles are shown to appear in a system of two coupled nonlinear oscillators. In this problem, two oscillators x_1 and x_2, have (the same) damping and Kerr nonlinearity and are linearly coupled,","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"beginalign\nddotx_1+ gamma dotx_1 + omega_0^2 x_1 + alpha x_1^3 + 2J(x_1-x_2) = F_0 cos(omega t) \nddotx_2+ gamma dotx_2 + omega_0^2 x_2 + alpha x_2^3 + 2J(x_2-x_1) = eta F_0 cos(omega t)\nendalign","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"using HarmonicBalance\n@variables γ, F, α, ω0, F0, η, ω, J, t, x(t), y(t);\n\ndiff_eq = DifferentialEquation([d(x,t,2) + γ * d(x,t) + ω0^2 * x + α*x^3+ 2*J*ω0*(x-y) - F0*cos(ω*t),\n            d(y,t,2) + γ * d(y,t) + ω0^2 * y + α*y^3 + 2*J*ω0*(y-x) - η*F0*cos(ω*t)], [x,y])\n","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"The analysis of Zambon et al. uses a frame rotating at the pump frequency omega to describe both oscillators. For us, this means we expand both modes using omega to obtain the harmonic equations.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"add_harmonic!(diff_eq, x, ω)\nadd_harmonic!(diff_eq, y, ω)\n\nharmonic_eq = get_harmonic_equations(diff_eq)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Solving for a range of drive amplitudes F_0,","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"fixed = (\n    ω0 => 1.4504859, # natural frequency of separate modes (in paper's notation, ħω0 - J)\n    γ => 27.4E-6,    # damping\n    J => 154.1E-6,   # coupling term\n    α => 3.867E-7,   # Kerr nonlinearity\n    ω => 1.4507941,  # pump frequency, resonant with antisymmetric mode (in paper, ħω0 + J)\n    η => -0.08,      # pumping leaking to site 2  (F2 = ηF1)\n    F0 => 0.002       # pump amplitude (overriden in sweeps)\n)\nvaried = F0 => LinRange(0.002, 0.03, 50)\n\nresult = get_steady_states(harmonic_eq, varied, fixed)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"A steady state result for 50 parameter points\n\nSolution branches:   9\n   of which real:    3\n   of which stable:  2","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Let us first see the steady states.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"p1 = plot(result, \"u1^2 + v1^2\", legend=false)\np2 = plot(result, \"u2^2 + v2^2\")\nplot(p1, p2)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"<img style=\"display: block; margin: 0 auto; padding-bottom: 20px\" src=\"../../assets/time_dependent/lc_steady.png\" alignment=\"center\"\\>","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"According to Zambon et al., a limit cycle solution exists around F_0 cong 0011, which can be accessed by a jump from branch 1 in an upwards sweep of F_0. Since a limit cycle is not a steady state of our harmonic equations, it does not appear in the diagram. We do however see that branch 1 ceases to be stable around F_0 cong 0010, meaning a jump should occur.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Let us try and simulate the limit cycle. We could in principle run a time-dependent simulation with a fixed value of F_0, but this would require a suitable initial condition. Instead, we will sweep F_0 upwards from a low starting value. To observe the dynamics just after the jump has occurred, we follow the sweep by a time interval where the system evolves under fixed parameters.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"import HarmonicBalance.TimeEvolution: ODEProblem, OrdinaryDiffEq.solve\ninitial_state = result[1][1]\n\nT = 2E6\nsweep = ParameterSweep(F0 => (0.002, 0.011), (0,T))\n\n# start from initial_state, use sweep, total time is 2*T\ntime_problem = ODEProblem(harmonic_eq, initial_state, sweep=sweep, timespan=(0,2*T))\ntime_evo = solve(time_problem, saveat=100);","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Inspecting the amplitude as a function of time,","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"plot(time_evo, \"sqrt(u1^2 + v1^2)\", harmonic_eq)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"<img style=\"display: block; margin: 0 auto; padding-bottom: 20px\" src=\"../../assets/time_dependent/lc_sweep.png\" alignment=\"center\" \\>","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"we see that initially the sweep is adiabatic as it proceeds along the steady-state branch 1. At around T = 2E6, an instability occurs and u_1(T) starts to rapidly oscillate. At that point, the sweep is stopped. Under free time evolution, the system then settles into a limit-cycle solution where the coordinates move along closed trajectories.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"By plotting the u and v variables against each other, we observe the limit cycle shapes in phase space,","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"p1 = plot(time_evo, [\"u1\", \"v1\"], harmonic_eq)\np2 = plot(time_evo, [\"u2\", \"v2\"], harmonic_eq)\nplot(p1, p2)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/time_dependent/lc_uv.png\" alignment=\"center\" \\>","category":"page"},{"location":"manual/solving_harmonics/#Solving-harmonic-equations","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"","category":"section"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Once a differential equation of motion has been defined in DifferentialEquation and converted to a HarmonicEquation, we may use the homotopy continuation method (as implemented in HomotopyContinuation.jl) to find steady states. This means that, having called get_harmonic_equations, we need to set all time-derivatives to zero and parse the resulting algebraic equations into a Problem.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Problem holds the steady-state equations, and (optionally) the symbolic Jacobian which is needed for stability / linear response calculations. ","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Once defined, a Problem can be solved for a set of input parameters using get_steady_states to obtain Result.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Problem\nget_steady_states\nResult","category":"page"},{"location":"manual/solving_harmonics/#HarmonicBalance.Problem","page":"Solving harmonic equations","title":"HarmonicBalance.Problem","text":"mutable struct Problem\n\nHolds a set of algebraic equations describing the steady state of a system.\n\nFields\n\nvariables::Vector{Symbolics.Num}: The harmonic variables to be solved for.\nparameters::Vector{Symbolics.Num}: All symbols which are not the harmonic variables.\nsystem::HomotopyContinuation.ModelKit.System: The input object for HomotopyContinuation.jl solver methods.\njacobian::Any: The Jacobian matrix (possibly symbolic).     If false, the Jacobian is ignored (may be calculated implicitly after solving).\neom::HarmonicEquation: The HarmonicEquation object used to generate this Problem.\n\nConstructors\n\nProblem(eom::HarmonicEquation; Jacobian=true) # find and store the symbolic Jacobian\nProblem(eom::HarmonicEquation; Jacobian=\"implicit\") # ignore the Jacobian for now, compute implicitly later\nProblem(eom::HarmonicEquation; Jacobian=J) # use J as the Jacobian (a function that takes a Dict)\nProblem(eom::HarmonicEquation; Jacobian=false) # ignore the Jacobian\n\n\n\n\n\n","category":"type"},{"location":"manual/solving_harmonics/#HarmonicBalance.get_steady_states","page":"Solving harmonic equations","title":"HarmonicBalance.get_steady_states","text":"get_steady_states(prob::Problem,\n                    swept_parameters::ParameterRange,\n                    fixed_parameters::ParameterList;\n                    method=:warmup,\n                    threading = Threads.nthreads() > 1,\n                    show_progress=true,\n                    sorting=\"nearest\")\n\nSolves prob over the ranges specified by swept_parameters, keeping fixed_parameters constant. swept_parameters accepts pairs mapping symbolic variables to arrays or LinRange. fixed_parameters accepts pairs mapping symbolic variables to numbers.\n\nKeyword arguments\n\nmethod: If :warmup (default), a problem similar to prob but with random complex parameters is first solved to find all non-singular paths. The subsequent tracking to find results for all sweptparameters is then much faster than the initial solving. If `method=:totaldegree`, each parameter point is solved separately by tracking the maximum number of paths (employs a total degree homotopy).\n\nThis takes far longer but can be more reliable.\n\nthreading: If true, multithreaded support is activated. The number of available threads is set by the environment variable JULIA_NUM_THREADS.\nsorting: the method used by sort_solutions to get continuous solutions branches.  The current options are \"hilbert\" (1D sorting along a Hilbert curve), \"nearest\" (nearest-neighbor sorting) and \"none\".\nshow_progress: Indicate whether a progress bar should be displayed.\n\nExample: solving a simple harmonic oscillator m ddotx + γ dotx + ω_0^2 x = F cos(ωt) to obtain the response as a function of ω\n\n# having obtained a Problem object, let's find steady states\njulia> range = ParameterRange(ω => LinRange(0.8,1.2,100) ) # 100 parameter sets to solve\njulia> fixed = ParameterList(m => 1, γ => 0.01, F => 0.5, ω_0 => 1)\njulia> get_steady_states(problem, range, fixed)\n\nA steady state result for 100 parameter points\n\n    Solution branches:   1\n       of which real:    1\n       of which stable:  1\n\n    Classes: stable, physical, Hopf, binary_labels\n\n\nIt is also possible to create multi-dimensional solutions plots.\n\n# The swept parameters take precedence over fixed -> use the same fixed\njulia> range = ParameterRange(ω => LinRange(0.8,1.2,100), F => LinRange(0.1,1.0,10) ) # 100x10 parameter sets\n\n# The swept parameters take precedence over fixed -> the F in fixed is now ignored\njulia> get_steady_states(problem, range, fixed)\n\nA steady state result for 1000 parameter points\n\n    Solution branches:   1\n       of which real:    1\n       of which stable:  1\n\n    Classes: stable, physical, Hopf, binary_labels\n\n\n\n\n\n","category":"function"},{"location":"manual/solving_harmonics/#HarmonicBalance.Result","page":"Solving harmonic equations","title":"HarmonicBalance.Result","text":"mutable struct Result\n\nStores the steady states of a HarmonicEquation.\n\nFields\n\nsolutions::Array{Vector{Vector{ComplexF64}}}: The variable values of steady-state solutions.\nswept_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Vector{Union{Float64, ComplexF64}}}: Values of all parameters for all solutions.\nfixed_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Float64}: The parameters fixed throughout the solutions.\nproblem::Problem: The Problem used to generate this.\nclasses::Dict{String, Array}: Maps strings such as \"stable\", \"physical\" etc to arrays of values, classifying the solutions (see method classify_solutions!).\njacobian::Union{Int64, Function}: The Jacobian with fixed_parameters already substituted. Accepts a dictionary specifying the solution.     If problem.jacobian is a symbolic matrix, this holds a compiled function.     If problem.jacobian was false, this holds a function that rearranges the equations to find J     only after numerical values are inserted (preferable in cases where the symbolic J would be very large).\nseed::Union{Nothing, UInt32}: Seed used for the solver\n\n\n\n\n\n","category":"type"},{"location":"manual/solving_harmonics/#Classifying-solutions","page":"Solving harmonic equations","title":"Classifying solutions","text":"","category":"section"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"The solutions in Result are accompanied by similarly-sized boolean arrays stored in the dictionary Result.classes. The classes can be used by the plotting functions to show/hide/label certain solutions.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"By default, classes \"physical\", \"stable\" and \"binary_labels\" are created. User-defined classification is possible with classify_solutions!.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"HarmonicBalance.classify_solutions!","category":"page"},{"location":"manual/solving_harmonics/#HarmonicBalance.classify_solutions!","page":"Solving harmonic equations","title":"HarmonicBalance.classify_solutions!","text":"classify_solutions!(\n    res::Result,\n    func::Union{Function, String},\n    name::String;\n    physical\n) -> Any\n\n\nCreates a solution class in res using the inequality condition (parsed into Symbolics.jl input).\n\nThe new class is labelled with name and stored under res.classes[name].\n\nBy default, only physical (=real) solutions are classified, false is returned for the rest.\n\nExample\n\n# solve a previously-defined problem\nres = get_steady_states(problem, swept_parameters, fixed_parameters)\n\n# classify, store in result.classes[\"large_amplitude\"]\nclassify_solutions!(res, \"sqrt(u1^2 + v1^2) > 1.0\" , \"large_amplitude\")\n\n\n\n\n\n","category":"function"},{"location":"manual/solving_harmonics/#Sorting-solutions","page":"Solving harmonic equations","title":"Sorting solutions","text":"","category":"section"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Solving a steady-state problem over a range of parameters returns a solution set for each parameter. For a continuous change of parameters, each solution in a set usually also changes continuously; it is said to form a ''solution branch''. For an example, see the three colour-coded branches for the Duffing oscillator in Example 1.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"For stable states, the branches describe a system's behaviour under adiabatic parameter changes. ","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Therefore, after solving for a parameter range, we want to order each solution set such that the solutions' order reflects the branches.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"The function sort_solutions goes over the the raw output of get_steady_states and sorts each entry such that neighboring solution sets minimize Euclidean distance.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Currently, sort_solutions is compatible with 1D and 2D arrays of solution sets.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"HarmonicBalance.sort_solutions","category":"page"},{"location":"manual/solving_harmonics/#HarmonicBalance.sort_solutions","page":"Solving harmonic equations","title":"HarmonicBalance.sort_solutions","text":"sort_solutions(\n    solutions::Array;\n    sorting,\n    show_progress\n) -> Any\n\n\nSorts solutions into branches according to the method sorting.\n\nsolutions is an n-dimensional array of Vector{Vector}. Each element describes a set of solutions for a given parameter set. The output is a similar array, with each solution set rearranged such that neighboring solution sets have the smallest Euclidean distance.\n\nKeyword arguments\n\nsorting: the method used by sort_solutions to get continuous solutions branches.  The current options are \"hilbert\" (1D sorting along a Hilbert curve), \"nearest\" (nearest-neighbor sorting) and \"none\".\nshow_progress: Indicate whether a progress bar should be displayed.\n\n\n\n\n\n","category":"function"},{"location":"manual/Krylov-Bogoliubov_method/#Krylov-Bogoliubov","page":"Krylov-Bogoliubov Averaging Method","title":"Krylov-Bogoliubov Averaging Method","text":"","category":"section"},{"location":"manual/Krylov-Bogoliubov_method/","page":"Krylov-Bogoliubov Averaging Method","title":"Krylov-Bogoliubov Averaging Method","text":"The Krylov-Bogoliubov averaging method is an alternative high-frequency expansion technique used to analyze dynamical systems. Unlike the Harmonic Balance method, which is detailed in the background section, the Krylov-Bogoliubov method excels in computing higher orders in 1omega, enabling the capture of faster dynamics within a system.","category":"page"},{"location":"manual/Krylov-Bogoliubov_method/#Purpose-and-Advantages","page":"Krylov-Bogoliubov Averaging Method","title":"Purpose and Advantages","text":"","category":"section"},{"location":"manual/Krylov-Bogoliubov_method/","page":"Krylov-Bogoliubov Averaging Method","title":"Krylov-Bogoliubov Averaging Method","text":"The primary advantage of the Krylov-Bogoliubov method lies in its ability to delve deeper into high-frequency components, allowing a more comprehensive understanding of fast dynamical behaviors. By leveraging this technique, one can obtain higher-order approximations that shed light on intricate system dynamics.","category":"page"},{"location":"manual/Krylov-Bogoliubov_method/","page":"Krylov-Bogoliubov Averaging Method","title":"Krylov-Bogoliubov Averaging Method","text":"However, it's essential to note a limitation: this method cannot handle multiple harmonics within a single variable, unlike some other high-frequency expansion methods.","category":"page"},{"location":"manual/Krylov-Bogoliubov_method/#Usage","page":"Krylov-Bogoliubov Averaging Method","title":"Usage","text":"","category":"section"},{"location":"manual/Krylov-Bogoliubov_method/","page":"Krylov-Bogoliubov Averaging Method","title":"Krylov-Bogoliubov Averaging Method","text":"To compute the Krylov-Bogoliubov averaging method within your system, utilize the function get_krylov_equations. This function is designed specifically to implement the methodology and derive the equations necessary to analyze the system dynamics using this technique.","category":"page"},{"location":"manual/Krylov-Bogoliubov_method/#Function-Reference","page":"Krylov-Bogoliubov Averaging Method","title":"Function Reference","text":"","category":"section"},{"location":"manual/Krylov-Bogoliubov_method/","page":"Krylov-Bogoliubov Averaging Method","title":"Krylov-Bogoliubov Averaging Method","text":"get_krylov_equations","category":"page"},{"location":"manual/Krylov-Bogoliubov_method/#HarmonicBalance.KrylovBogoliubov.get_krylov_equations","page":"Krylov-Bogoliubov Averaging Method","title":"HarmonicBalance.KrylovBogoliubov.get_krylov_equations","text":"get_krylov_equations(\n    diff_eom::DifferentialEquation;\n    order,\n    fast_time,\n    slow_time\n)\n\n\nApply the Krylov-Bogoliubov averaging method to a specific order to obtain a set of ODEs (the slow-flow equations) governing the harmonics of diff_eom.\n\nThe harmonics evolve in slow_time, the oscillating terms themselves in fast_time. If no input is used, a variable T is defined for slow_time and fast_time is taken as the independent variable of diff_eom.\n\nKrylov-Bogoliubov averaging method can be applied up to order = 2.\n\nExample\n\njulia> @variables t, x(t), ω0, ω, F;\n\n# enter the simple harmonic oscillator\njulia> diff_eom = DifferentialEquation( d(x,t,2) + ω0^2 * x ~ F *cos(ω*t), x);\n\n# expand x in the harmonic ω\njulia> add_harmonic!(diff_eom, x, ω);\n\n# get equations for the harmonics evolving in the slow time T to first order\njulia> harmonic_eom = get_krylov_equations(diff_eom, order = 1)\n\nA set of 2 harmonic equations\nVariables: u1(T), v1(T)\nParameters: ω, F, ω0\n\nHarmonic ansatz:\nxˍt(t) =\nx(t) = u1(T)*cos(ωt) + v1(T)*sin(ωt)\n\nHarmonic equations:\n\n((1//2)*(ω^2)*v1(T) - (1//2)*(ω0^2)*v1(T)) / ω ~ Differential(T)(u1(T))\n\n((1//2)*(ω0^2)*u1(T) - (1//2)*F - (1//2)*(ω^2)*u1(T)) / ω ~ Differential(T)(v1(T))\n\n\n\n\n\n","category":"function"},{"location":"manual/Krylov-Bogoliubov_method/","page":"Krylov-Bogoliubov Averaging Method","title":"Krylov-Bogoliubov Averaging Method","text":"For further information and a detailed understanding of this method, refer to Krylov-Bogoliubov averaging method on Wikipedia.","category":"page"},{"location":"examples/linear_response/#linresp_ex","page":"Introduction: linear response","title":"Introduction: linear response","text":"","category":"section"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"In HarmonicBalance.jl, the stability and linear response are treated using the LinearResponse module. ","category":"page"},{"location":"examples/linear_response/#Example:-driven-Duffing-resonator","page":"Introduction: linear response","title":"Example: driven Duffing resonator","text":"","category":"section"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"Here we calculate the white noise response of a simple nonlinear system. A set of reference results may be found in Huber et al. in Phys. Rev. X 10, 021066 (2020). The code is also available as a Jupyter notebook. ","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"We start by defining the Duffing oscillator","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"using HarmonicBalance\nimport HarmonicBalance.LinearResponse.plot_linear_response\n@variables α, ω, ω0, F, γ, t, x(t); # declare constant variables and a function x(t)\n\n# define ODE\ndiff_eq = DifferentialEquation(d(x,t,2) + ω0*x + α*x^3 + γ*d(x,t) ~ F*cos(ω*t), x)\n\n# specify the ansatz x = u(T) cos(ω*t) + v(T) sin(ω*t)\nadd_harmonic!(diff_eq, x, ω) \n\n# implement ansatz to get harmonic equations\nharmonic_eq = get_harmonic_equations(diff_eq)","category":"page"},{"location":"examples/linear_response/#Linear-regime","page":"Introduction: linear response","title":"Linear regime","text":"","category":"section"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"When driven weakly, the Duffing resonator behaves quasi-linearly, i.e, its response to noise is independent of the applied drive. We see that for weak driving, F = 10^-6, the amplitude is a Lorentzian. ","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"fixed = (α => 1, ω0 => 1.0, γ => 1E-2, F => 1E-6)   # fixed parameters\nvaried = ω => LinRange(0.9, 1.1, 100)           # range of parameter values\nresult = get_steady_states(harmonic_eq, varied, fixed)\n\nplot(result, \"sqrt(u1^2 + v1^2)\")","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; margin: 0 auto; padding-bottom: 20px;\" src=\"../../assets/linear_response/quasilin_amp.png\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"⠀ The linear response is obtained with plot_linear_response, note that the branch number and the variable (here x) must be specified. The response has a peak at omega_0, irrespective of omega :","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"plot_linear_response(result, x, Ω_range=LinRange(0.9,1.1,300), branch=1, logscale=true)","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/linear_response/quasilin_noise.png\" alignment=\"left\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"⠀ Note the slight \"bending\" of the noise peak with omega - this is given by the failure of the first-order calculation to capture response far-detuned from the drive frequency. More on this point will follow in a future example.","category":"page"},{"location":"examples/linear_response/#Nonlinear-regime","page":"Introduction: linear response","title":"Nonlinear regime","text":"","category":"section"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"For strong driving, matters get more complicated. Let us now use a drive F = 10^-2 :","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"fixed = (α => 1, ω0 => 1.0, γ => 1E-2, F => 1E-2)   # fixed parameters\nswept = ω => LinRange(0.9, 1.1, 100)           # range of parameter values\nresult = get_steady_states(harmonic_eq, swept, fixed)\n\nplot(result, x=\"ω\", y=\"sqrt(u1^2 + v1^2)\");","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/linear_response/nonlin_amp.png\" alignment=\"left\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"⠀","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"The amplitude is the well-known Duffing curve. Let's see the linear response of the two stable branches, 1 and 2.","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"plot_linear_response(result, x, branch=1, \n    Ω_range=LinRange(0.9,1.1,300), logscale=true)\n\nplot_linear_response(result, x, branch=2, \n    Ω_range=LinRange(0.9,1.1,300), logscale=true)","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; padding-bottom: 20px;\" src=\"../../assets/linear_response/nonlin_noise.png\" alignment=\"center\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"⠀ In branch 1 the linear response to white noise shows more than one peak. This is a distinctly nonlinear phenomenon, manifesting primarily at large amplitudes. Branch 2 is again quasi-linear, which stems from its low amplitude.","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"Following Huber et al., we may also fix omega = omega_0 and plot the linear response as a function of F. The response turns out to be single-valued over a large range of driving strengths. Using a log scale for the x-axis:","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"fixed = (α => 1., ω0 => 1.0, γ => 1E-2, ω => 1)   # fixed parameters\nswept = F => 10 .^ LinRange(-6, -1, 200)           # range of parameter values\nresult = get_steady_states(harmonic_eq, swept, fixed)\n\nplot(result, \"sqrt(u1^2 + v1^2)\", xscale=:log)\n\nplot_linear_response(result, x, branch=1, \n    Ω_range=LinRange(0.9,1.1,300), order=1, logscale=true, xscale=:log)","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/linear_response/nonlin_F_noise.png\" alignment=\"left\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"We see that for low F, quasi-linear behaviour with a single Lorentzian response occurs, while for larger F, two peaks form in the noise response. The two peaks are strongly unequal in magnitude, which is an example of internal squeezing.","category":"page"},{"location":"background/stability_response/#linresp_background","page":"Stability and linear response","title":"Stability and linear response","text":"","category":"section"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"The core of the harmonic balance method is expressing the system's behaviour in terms of Fourier components or harmonics. For an N-coordinate system, we choose a set of M_i harmonics to describe each coordinate x_i : ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation labeleqansatz\nx_i(t) = sum_j=1^M_i u_ij  (T)  cos(omega_ij t)+ v_ij (T) sin(omega_ij t) \nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"This means the system is now described using a discrete set of variables u_ij and v_ij. Constructing the vector ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation labeleqharmvar\nmathbfu(T) = (u_11(T) v_11(T) ldots u_NM_N(T) v_N M_N(T))\nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"we may obtain the harmonic equations (see an example of this procedure)","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation labeleqharmeq\nfracdmathbfu(T)dT  = barmathbfF (mathbfu)\nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"where barmathbfF(mathbfu) is a nonlinear function. A steady state mathbfu_0 is defined by barmathbfF(mathbfu_0) = 0.","category":"page"},{"location":"background/stability_response/#Stability","page":"Stability and linear response","title":"Stability","text":"","category":"section"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Let us assume that we found a steady state mathbfu_0. When the system is in this state, it responds to small perturbations either by returning to mathbfu_0 over some characteristic timescale (stable state) or by evolving away from mathbfu_0 (unstable state). To analyze the stability of mathbfu_0, we linearize Eq. \\eqref{eq:harmeq} around mathbfu_0 for a small perturbation delta mathbfu = mathbfu - mathbfu_0 to obtain","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation labeleqJaceq\nfracddT leftdelta mathbfu(T)right =  J(mathbfu_0) delta mathbfu(T) \nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"where J(mathbfu_0)=nabla_mathbfu  barmathbfF_mathbfu=mathbfu_0 is the Jacobian matrix of the system evaluated at mathbfu=mathbfu_0.","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Eq. \\eqref{eq:Jaceq} is exactly solvable for delta mathbfu(T) given an initial condition delta mathbfu(T_0). The solution can be expanded in terms of the complex eigenvalues lambda_r and eigenvectors mathbfv_r of J(mathbfu_0), namely","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation labeleqfluct_evo\n    delta mathbfu(T) = sum_r c_r hspace1mmmathbfv_r e^lambda_r T\nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"The dynamical behaviour near the steady states is thus governed by e^ lambda_r T: if mathrmRe(lambda_r)0 for all lambda_r, the state mathbfu_0 is stable. Conversely, if mathrmRe(lambda_r)0 for at least one lambda_r, the state is unstable - perturbations such as noise or a small applied drive will force the system away from mathbfu_0. ","category":"page"},{"location":"background/stability_response/#Linear-response","page":"Stability and linear response","title":"Linear response","text":"","category":"section"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"The response of a stable steady state to an additional oscillatory force, caused by weak probes or noise, is often of interest. It can be calculated by solving for the perturbation delta mathbfu(T) in the presence of an additional drive term.","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation labeleqJacforced\nfracddT leftdelta mathbfu(T)right =  J(mathbfu_0) delta mathbfu(T) + boldsymbolxi e^i Omega T\nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Suppose we have found an eigenvector of J(mathbfu_0) such that J(mathbfu) mathbfv = lambda mathbfv. To solve Eq. \\eqref{eq:Jacforced}, we insert delta mathbfu(T) = A(Omega) mathbfv e^i Omega T. Projecting each side of Eq. \\eqref{eq:Jacforced} onto mathbfv gives","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"A(Omega) left( i Omega  - lambda right)  = boldsymbolxi cdot mathbfv quad implies quad A(Omega) = fracboldsymbolxi cdot mathbfv -textRelambda + i left( Omega - textImlambda right)","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"We see that each eigenvalue lambda results in a linear response that is a Lorentzian centered at Omega = textImlambda. Effectively, the linear response matches that of a harmonic oscillator with resonance frequency textImlambda and damping textRelambda.","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Knowing the response of the harmonic variables mathbfu(T), what is the corresponding behaviour of the \"natural\" variables x_i(t) ? To find this out, we insert the perturbation back into the harmonic ansatz \\eqref{eq:ansatz}. Since we require real variables, let us use delta mathbfu(T) = A(Omega) left( mathbfv  e^i Omega T +   mathbfv^*  e^-i Omega T right). Plugging this into","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation\ndelta x_i(t) = sum_j=1^M_i deltau_ij(t) cos(omega_ij t) + delta v_ij (t) sin(omega_ij t) \nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"and multiplying out the sines and cosines gives","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginalign labeleqdeltax\ndelta x_i(t) = sum_j=1^M_i bigg left( textRedelta u_ij - textImdelta v_ij right) cos(omega_ij - Omega) t  \n+ left( textImdelta u_ij + textRedelta v_ij right) sin(omega_ij - Omega) t nonumber \n+ left( textRedelta u_ij + textImdelta v_ij right) cos(omega_ij + Omega) t nonumber \n+ left( -textImdelta u_ij + textRedelta v_ij right) sin(omega_ij + Omega) t bigg nonumber\nendalign","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"where delta u_ij and delta v_ij are the components of delta mathbfu corresponding to the respective harmonics omega_ij. ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"We see that a motion of the harmonic variables at frequency Omega appears as motion of delta x_i(t) at frequencies omega_ijpm Omega. ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"To make sense of this, we normalize the vector delta mathbfu and use normalised components delta hatu_ij and delta hatv_ij. We also define the Lorentzian distribution","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation\nL(x)_x_0 gamma = frac1left( x - x_0 right)^2 + gamma^2 \nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"We see that all components of delta x_i(t) [Eq. \\eqref{eq:deltax}] are proportional to L(Omega)_textImlambda textRelambda. The first and last two summands are Lorentzians centered at pm Omega which oscillate at omega_ij pm Omega, respectively. From this, we can extract the linear response function in Fourier space, chi (tildeomega)","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginmultline\n chi delta x _i(tildeomega) ^2 = sum_j=1^M_i bigg  left left( textRedelta hatu_ij - textImdelta hatv_ij right)^2 + left( textImdelta hatu_ij + textRedelta hatv_ij right)^2 right L(omega_ij - tildeomega)_textImlambda textRelambda \n+ left left( textRedelta hatu_ij + textImdelta hatv_ij right)^2 + left(  textRedelta hatv_ij - textImdelta hatu_ij right)^2 right L(tildeomega - omega_ij)_textImlambda textRelambda bigg\nendmultline","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Keeping in mind that L(x)_x_0 gamma = L(x + Delta)_x_0 + Delta gamma and the normalization delta hatu_ij^2 + delta hatv_ij^2 = 1, we can rewrite this as","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation\nchi delta x _i(tildeomega)^2 = sum_j=1^M_i left( 1 + alpha_ij right) L(tildeomega)_omega_ij - textImlambda textRelambda\n+ left( 1 - alpha_ij right) L(tildeomega)_omega_ij + textImlambda textRelambda\nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"where ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"alpha_ij = 2left( textImdelta hatu_ij textRedelta hatv_ij - textRedelta hatu_ij textImdelta hatv_ij right)","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"The above solution applies to every eigenvalue lambda of the Jacobian. It is now clear that the linear response function chi delta x _i(tildeomega) contains for each eigenvalue lambda_r and harmonic omega_ij : ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"A Lorentzian centered at omega_ij-textImlambda_r with amplitude 1 + alpha_ij^(r) \nA Lorentzian centered at omega_ij+textImlambda_r with amplitude 1 - alpha_ij^(r) ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Sidenote: As J a real matrix, there is an eigenvalue lambda_r^* for each lambda_r. The maximum number of peaks in the linear response is thus equal to the dimensionality of mathbfu(T).","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"The linear response of the system in the state mathbfu_0 is thus fully specified by the complex eigenvalues and eigenvectors of J(mathbfu_0). In HarmonicBalance.jl, the module LinearResponse creates a set of plottable Lorentzian objects to represent this.","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Check out this example of the linear response module of HarmonicBalance.jl","category":"page"},{"location":"examples/limit_cycles/#Limit-cycles","page":"Limit cycles","title":"Limit cycles","text":"","category":"section"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"In contrast to the previous examples, limit cycle problems feature harmonic(s) whose numerical value is not imposed externally. We shall construct our HarmonicEquation as usual, but identify this harmonic as an extra variable, rather than a fixed parameter.","category":"page"},{"location":"examples/limit_cycles/#Non-driven-system-the-van-der-Pol-oscillator","page":"Limit cycles","title":"Non-driven system - the van der Pol oscillator","text":"","category":"section"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"Here we solve the equation of motion of the van der Pol oscillator. This is a single-variable second-order ODE with continuous time-translation symmetry (i.e., no 'clock' imposing a frequency and/or phase), which displays periodic solutions known as relaxation oscillations. For more detail, refer also to arXiv:2308.06092.","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"using HarmonicBalance\n@variables ω_lc, t, ω0, x(t), μ\ndiff_eq = DifferentialEquation(d(d(x,t),t) - μ*(1-x^2) * d(x,t) + x, x)","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"Choosing to expand the motion of x(t) using ω_lc, 3ω_lc and 5ω_lc, we define","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"[add_harmonic!(diff_eq, x, i*ω_lc) for i in 1:2:5]","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"and obtain 6 harmonic equations,","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"harmonic_eq = get_harmonic_equations(diff_eq)","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"A set of 6 harmonic equations\nVariables: u1(T), v1(T), u2(T), v2(T), u3(T), v3(T)\nParameters: ω_lc, μ","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"So far, ω_lc appears as any other harmonic. However, it is not fixed by any external drive or 'clock', instead, it emerges out of a Hopf instability in the system. We can verify that fixing ω_lc and calling get_steady_states.","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"get_steady_states(harmonic_eq, μ => 1:0.1:5, ω_lc => 1.2)","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"gives a single solution with zero amplitude.","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"Taking instead ω_lc as a variable to be solved for results in a phase freedom, implying an infinite number of solutions. To perform the gauge-fixing procedure, we call get_limit_cycles, marking the limit cycle harmonic as a keyword argument,","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"import HarmonicBalance.LimitCycles: get_limit_cycles\nresult = get_limit_cycles(harmonic_eq, μ => 1:0.1:5, (), cycle_harmonic = ω_lc)","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"A steady state result for 41 parameter points\n\nSolution branches:   100\n   of which real:    4\n   of which stable:  4 ","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"The results show a fourfold degeneracy of solutions. The automatically created solution class unique_cycle filters the degeneracy out,","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"plot(result, ω_lc)","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"(Image: fig1)","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"plot(result, ω_lc, class=\"unique_cycle\")","category":"page"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"(Image: fig2)","category":"page"},{"location":"examples/limit_cycles/#Driven-system-coupled-Duffings","page":"Limit cycles","title":"Driven system - coupled Duffings","text":"","category":"section"},{"location":"examples/limit_cycles/","page":"Limit cycles","title":"Limit cycles","text":"Under construction, see Chapter 6.2.2 of Jan's thesis","category":"page"},{"location":"manual/linear_response/#linresp_man","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"This module currently has two goals. One is calculating the first-order Jacobian, used to obtain stability and approximate (but inexpensive) the linear response of steady states. The other is calculating the full response matrix as a function of frequency; this is more accurate but more expensive. ","category":"page"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"The methodology used is explained in Jan Kosata phd thesis.","category":"page"},{"location":"manual/linear_response/#Stability","page":"Linear response (WIP)","title":"Stability","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"The Jacobian is used to evaluate stability of the solutions. It can be shown explicitly,","category":"page"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"HarmonicBalance.get_Jacobian","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.get_Jacobian","page":"Linear response (WIP)","title":"HarmonicBalance.LinearResponse.get_Jacobian","text":"get_Jacobian(eom)\n\n\nObtain the symbolic Jacobian matrix of eom (either a HarmonicEquation or a DifferentialEquation). This is the linearised left-hand side of F(u) = du/dT.\n\n\n\n\n\nObtain a Jacobian from a DifferentialEquation by first converting it into a HarmonicEquation. \n\n\n\n\n\nGet the Jacobian of a set of equations eqs with respect to the variables vars. \n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/#Linear-response","page":"Linear response (WIP)","title":"Linear response","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"The response to white noise can be shown with plot_linear_response. Depending on the order argument, different methods are used. ","category":"page"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"HarmonicBalance.LinearResponse.plot_linear_response","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.plot_linear_response","page":"Linear response (WIP)","title":"HarmonicBalance.LinearResponse.plot_linear_response","text":"plot_linear_response(res::Result, nat_var::Num; Ω_range, branch::Int, order=1, logscale=false, show_progress=true, kwargs...)\n\nPlot the linear response to white noise of the variable nat_var for Result res on branch for input frequencies Ω_range. Slow-time derivatives up to order are kept in the process.\n\nAny kwargs are fed to Plots' gr().\n\nSolutions not belonging to the physical class are ignored.\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/#First-order","page":"Linear response (WIP)","title":"First order","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"The simplest way to extract the linear response of a steady state is to evaluate the Jacobian of the harmonic equations. Each of its eigenvalues lambda describes a Lorentzian peak in the response; textRelambda gives its center and textImlambda its width. Transforming the harmonic variables into the non-rotating frame (that is, inverting the harmonic ansatz) then gives the response as it would be observed in an experiment.","category":"page"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"The advantage of this method is that for a given parameter set, only one matrix diagonalization is needed to fully describe the response spectrum. However, the method is inaccurate for response frequencies far from the frequencies used in the harmonic ansatz (it relies on the response oscillating slowly in the rotating frame). ","category":"page"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"Behind the scenes, the spectra are stored using the dedicated structs Lorentzian and JacobianSpectrum.","category":"page"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"HarmonicBalance.LinearResponse.JacobianSpectrum\nHarmonicBalance.LinearResponse.Lorentzian","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.JacobianSpectrum","page":"Linear response (WIP)","title":"HarmonicBalance.LinearResponse.JacobianSpectrum","text":"mutable struct JacobianSpectrum\n\nHolds a set of Lorentzian objects belonging to a variable.\n\nFields\n\npeaks::Vector{HarmonicBalance.LinearResponse.Lorentzian}\n\nConstructor\n\nJacobianSpectrum(res::Result; index::Int, branch::Int)\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.Lorentzian","page":"Linear response (WIP)","title":"HarmonicBalance.LinearResponse.Lorentzian","text":"struct Lorentzian\n\nHolds the three parameters of a Lorentzian peak, defined as A / sqrt((ω-ω0)² + Γ²).\n\nFields\n\nω0::Float64\nΓ::Float64\nA::Float64\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_response/#Higher-orders","page":"Linear response (WIP)","title":"Higher orders","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"Setting order > 1 increases the accuracy of the response spectra. However, unlike for the Jacobian, here we must perform a matrix inversion for each response frequency.  ","category":"page"},{"location":"manual/linear_response/","page":"Linear response (WIP)","title":"Linear response (WIP)","text":"HarmonicBalance.LinearResponse.ResponseMatrix\nHarmonicBalance.get_response\nHarmonicBalance.LinearResponse.get_response_matrix","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.ResponseMatrix","page":"Linear response (WIP)","title":"HarmonicBalance.LinearResponse.ResponseMatrix","text":"struct ResponseMatrix\n\nHolds the compiled response matrix of a system.\n\nFields\n\nmatrix::Matrix{Function}: The response matrix (compiled).\nsymbols::Vector{Symbolics.Num}: Any symbolic variables in matrix to be substituted at evaluation.\nvariables::Vector{HarmonicVariable}: The frequencies of the harmonic variables underlying matrix. These are needed to transform the harmonic variables to the non-rotating frame.\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.get_response","page":"Linear response (WIP)","title":"HarmonicBalance.LinearResponse.get_response","text":"get_response(\n    rmat::HarmonicBalance.LinearResponse.ResponseMatrix,\n    s::OrderedCollections.OrderedDict{Symbolics.Num, ComplexF64},\n    Ω\n) -> Any\n\n\nFor rmat and a solution dictionary s, calculate the total response to a perturbative force at frequency Ω.\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.get_response_matrix","page":"Linear response (WIP)","title":"HarmonicBalance.LinearResponse.get_response_matrix","text":"get_response_matrix(diff_eq::DifferentialEquation, freq::Num; order=2)\n\nObtain the symbolic linear response matrix of a diff_eq corresponding to a perturbation frequency freq. This routine cannot accept a HarmonicEquation since there, some time-derivatives are already dropped. order denotes the highest differential order to be considered.\n\n\n\n\n\n","category":"function"},{"location":"background/harmonic_balance/#intro_hb","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"","category":"section"},{"location":"background/harmonic_balance/#prelude","page":"The method of harmonic balance","title":"Frequency conversion in oscillating nonlinear systems","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"HarmonicBalance.jl focuses on harmonically-driven nonlinear systems, i.e., dynamical systems governed by equations of motion where all explicitly time-dependent terms are harmonic. Let us take a general nonlinear system of N second-order ODEs with real variables x_i(t), i = 12cdotsN and time t as the independent variable,","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqode\n  ddotmathbfx(t)+ mathbfF(mathbfx(t) t)=0\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"The vector mathbfx(t) = (x_1(t)  x_N(t))^text T fully describes the state of the system.  Physically, mathbfx(t) encompasses the amplitudes of either point-like or collective oscillators (e.g., mechanical resonators, voltage oscillations in RLC circuits, an oscillating electrical dipole moment, or standing modes of an optical cavity). ","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"As the simplest example, let us first solve the harmonic oscillator in frequency space. The equation of motion is","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\nddotx(t) + gamma dotx(t) + omega_0^2 x(t) = F cos(omega_d t)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"where gamma is the damping coefficient and omega_0 the natural frequency. Fourier-transforming both sides of this equation gives","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n(omega_0^2 - omega^2 + i omega gamma) tildex(omega) = fracF2 left delta(omega + omega_d) + delta(omega - omega_d) right \nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Evidently, tildex(omega) is only nonvanishing for omega = pm omega_d. The system thus responds at the driving frequency only - the behaviour can be captured by a single harmonic. This illustrates the general point that linear systems are exactly solvable by transforming to Fourier space, where the equations are diagonal.","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"The situation becomes more complex if nonlinear terms are present, as these cause frequency conversion. Suppose we add a quadratic nonlinearity beta x^2(t) to the equations of motion; an attempt to Fourier-transform gives","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqduffingFT\n    textFTx^2(omega) =  int x^2(t) e^-iomega t  dt = int_-infty^+infty tildex(omega)tildex(omega) delta(omega+omega-omega)  domega  domega \nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"which couples all harmonics omega omega omega such that omega + omega + omega = 0. To lowest order, this means the induced motion at the drive frequency generates a higher harmonic, omega_d rightarrow 2omega_d. To higher orders however, the frequency conversion propagates through the spectrum, coupling an infinite number of harmonics. The system is not solvable in Fourier space anymore!","category":"page"},{"location":"background/harmonic_balance/#Harmonic-ansatz-and-harmonic-equations","page":"The method of harmonic balance","title":"Harmonic ansatz & harmonic equations","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Even though we need an infinity of Fourier components to describe our system exactly, some components are more important than others. The strategy of harmonic balance is to describe the motion of any variable x_i(t) in a truncated Fourier space","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\nx_i(t) = sum_j=1^M_i u_ij  (T)  cos(omega_ij t)+ v_ij (T) sin(omega_ij t) \nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Within this space, the system is described by a finite-dimensional vector","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqharmansatz\nmathbfu(T) = (u_11(T) v_11(T) ldots u_N M_N(T) v_N M_N(T))\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Under the assumption that mathbfu(T) evolves at much slower timescales than the oscillatory terms omega_ij t, we may neglect all of its higher order time derivatives. Notice that once ansatz \\eqref{eq:harmansatz} is used in Eq. \\eqref{eq:ode}, all terms become oscillatory - each prefactor of cos(omega_ij t) and sin(omega_ij t) thus generates a separate equation. Collecting these, we obtain a 1st order nonlinear ODEs,","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqharmeq\nfracdmathbfu(T)dT  = barmathbfF (mathbfu)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"which we call the harmonic equations. The main purpose of HarmonicBalance.jl is to obtain and solve them. We are primarily interested in steady states mathbfu_0 defined by barmathbfF(mathbfu_0) = 0.","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"The process of obtaining the harmonic equations is best shown on an example.","category":"page"},{"location":"background/harmonic_balance/#Duffing_harmeq","page":"The method of harmonic balance","title":"Example: the Duffing oscillator","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Here, we derive the harmonic equations for a single Duffing resonator, governed by the equation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqduffing\n    ddotx(t) + omega_0^2 x(t) + alpha x^3(t) = F cos(omega_d t + theta)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"As explained in above, for a periodic driving at frequency omega_d and a weak nonlinearity alpha, we expect the response at frequency omega_d to dominate, followed by a response at 3omega_d due to frequency conversion.","category":"page"},{"location":"background/harmonic_balance/#Single-frequency-ansatz","page":"The method of harmonic balance","title":"Single-frequency ansatz","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"We first attempt to describe the steady states of Eq. \\eqref{eq:duffing} using only one harmonic, omega_d. The starting point is the harmonic ansatz for x","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n\tx(t) = u(T) cos(omega_d t) + v(T) sin(omega_d t)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"with the harmonic variables u and v. The slow time T is, for now, equivalent to t. Substituting this ansatz into Eq. \\eqref{eq:duffing} results in","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginalign labeleqansatz1\n\tleftddotu + 2 omega_d dotv + u left(omega_0^2 - omega_d^2 right) +  frac3 alpha left(u^3 + uv^2right)4 + F costhetaright cos(omega_d t) \n\t+ leftddotv - 2 omega_d dotu + v left(omega_0^2 - omega_d^2 right)  +frac3 alpha left(v^3 + u^2 vright)4 - F sinthetaright sin(omega_d t) nonumber \n\t+ fracalpha left(u^3 - 3 u v^2right)4 cos(3 omega_d t) +  fracalpha left(3u^2 v - v^3right)4 sin(3 omega_d t) = 0 nonumber\nendalign","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"We see that the x^3 term has generated terms that oscillate at 3omega_d, describing the process of frequency upconversion. We now Fourier-transform both sides of Eq. \\eqref{eq:ansatz1} with respect to omega_d to obtain the harmonic equations. This process is equivalent to extracting the respective coefficients of cos(omega_d t) and sin(omega_d t). Here the distinction between t and T becomes important: since the evolution of u(T) and v(T) is assumed to be slow, they are treated as constant for the purpose of the Fourier transformation. Since we are interested in steady states, we drop the higher-order derivatives and rearrange the resulting equation to","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n\tfracddT beginpmatrix u  v  endpmatrix = frac18 omega_d beginpmatrix 4 v left(omega_0^2-omega_d^2 right) + 3 alpha left(v^3 + u^2 v  right) - 4 F sintheta   4 u left(omega_d^2-omega_0^2 right)  - 3 alpha left(u^3 + u v^2 right) - 4 F costheta  endpmatrix \nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Steady states can now be found by setting the l.h.s. to zero, i.e., assuming u(T) and v(T) constant and neglecting any transient behaviour. This results in a set of 2 nonlinear polynomial equations of order 3, for which the maximum number of solutions set by Bézout's theorem is 3^2=9. Depending on the parameters, the number of real solutions is known to be between 1 and 3.","category":"page"},{"location":"background/harmonic_balance/#Sidenote:-perturbative-approach","page":"The method of harmonic balance","title":"Sidenote: perturbative approach","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"The steady states describe a response that may be recast as x_0(t) = X_0 cos(omega_d t + phi), where X_0=sqrtu^2+v^2 and phi=-textatan(vu). Frequency conversion from omega_d to 3 omega_d can be found by setting x(t) equiv x_0(t) + delta x(t) with delta x(t)llx_0(t) and expanding Eq. \\eqref{eq:duffing} to first-order in delta x(t). The resulting equation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n    delta ddotx(t) + leftomega_0^2 + frac3 alpha X_0^24 rightdelta x(t) = - fracalpha X_0^34 cos(3 omega_d t + 3 phi)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"describes a simple harmonic oscillator, which is exactly soluble. Correspondingly, a response of delta x(t) at frequency 3 omega_d is observed. Since this response is obtained 'on top of' each steady state of Eq. \\eqref{eq:duffing}, no previously-unknown solutions are generated in the process.","category":"page"},{"location":"background/harmonic_balance/#Two-frequency-ansatz","page":"The method of harmonic balance","title":"Two-frequency ansatz","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"An approach in the spirit of harmonic balance is to use both harmonics omega_d and 3 omega_d on the same footing, i.e., to insert the ansatz","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n\tx(t) = u_1(T) cos(omega_d t) + v_1(T) sin(omega_d t) + u_2(T) cos(3 omega_d t) + v_2(T) sin(3omega_d t)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"with u_1 u_2 v_1 v_2 being the harmonic variables. As before we substitute the ansatz into Eq. \\eqref{eq:duffing}, drop second derivatives with respect to T and Fourier-transform both sides. Now, the respective coefficients correspond to cos(omega_d t), sin(omega_d t), cos(3 omega_d t) and sin(3omega_d t). Rearranging, we obtain","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"\tbeginalign\n\tbeginsplit\n\tfracdu_1dT =  frac12omega_d left left(omega_0^2 - omega_d^2 right) v_1 + frac3alpha4 left( v_1^3 + u_1^2 v_1 + u_1^2 v_2 - v_1^2 v_2 + 2 u_2^2 v_1 + 2 v_2^2 v_1 - 2 u_1 u_2 v_1right)  + F sintheta right\n\t\n\tfracdv_1dT = frac12omega_d left left(omega_d^2 - omega_0^2 right) u_1 - frac3 alpha4 left( u_1^3 + u_1^2 u_2 + v_1^2 u_1 - v_1^2 u_2+ 2 u_2^2 u_1 + 2 v_2^2 u_1  + 2 u_1 v_1 v_2right) - F costheta right\n\t\n\tfracd u_2dT = frac16 omega_d left left(omega_0^2 - 9omega_d^2 right) v_2 + fracalpha4 left( - v_1^3 + 3 v_2^3 + 3 u_1^2 v_1 + 6 u_1^2 v_2 + 3 u_2^2 v_2 + 6 v_1^2 v_2right) right\n\t\n\tfracdv_2dT = frac16 omega_d left left(9omega_d^2 - omega_0^2right) u_2 - fracalpha4 left( u_1^3 + 3 u_2^3 + 6 u_1^2 u_2 - 3 v_1^2 u_1 + 3 v_2^2 u_2 + 6 v_1^2 u_2right) right \n\tendsplit\n\tendalign","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"In contrast to the single-frequency ansatz [Eqs. \\eqref{eq:ansatz1}],  we now have 4 equations of order 3, allowing up to 3^4=81 solutions (the number of unique real ones is again generally far smaller). The larger number of solutions is explained by higher harmonics which cannot be captured perturbatively by the single-frequency ansatz. In particular, those where the 3 omega_d component is significant. Such solutions appear, e.g., for omega_d approx omega_0  3 where the generated 3 omega_d harmonic is close to the natural resonant frequency. See the examples for numerical results.","category":"page"},{"location":"#HarmonicBalance.jl","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"HarmonicBalance.jl is a Julia package for solving nonlinear differential equations using the method of harmonic balance.","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"This repo contains a collection of example notebooks.","category":"page"},{"location":"#Installation","page":"HarmonicBalance.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"To install HarmonicBalance.jl, you can use the github repo https://github.com/NonlinearOscillations/HarmonicBalance.jl or the Julia package manager,","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"using Pkg\nPkg.add(\"HarmonicBalance\")","category":"page"},{"location":"#Citation","page":"HarmonicBalance.jl","title":"Citation","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"If you use HarmonicBalance.jl in your project, we kindly ask you to cite this paper:","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"@article{10.21468/SciPostPhysCodeb.6,\n\ttitle={{HarmonicBalance.jl: A Julia suite for nonlinear dynamics using harmonic  balance}},\n\tauthor={Jan Košata and Javier del Pino and Toni L. Heugel and Oded Zilberberg},\n\tjournal={SciPost Phys. Codebases},\n\tpages={6},\n\tyear={2022},\n\tdoi={10.21468/SciPostPhysCodeb.6},\n\turl={https://scipost.org/10.21468/SciPostPhysCodeb.6},\n}","category":"page"},{"location":"#[Simple-example](https://nonlinearoscillations.github.io/HarmonicBalance.jl/stable/examples/simple_Duffing/)","page":"HarmonicBalance.jl","title":"Simple example","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"Let's find the steady states of a driven Duffing oscillator with nonlinear damping, its equation of motion is:","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"beginequation labeleqduffing\nunderbraceddotx(t) + gamma dotx(t) + omega_0^2 x(t)_textdamped harmonic oscillator + underbracealpha x(t)^3_textDuffing coefficient = underbraceF cos(omega t)_textperiodic drive\nendequation","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"using HarmonicBalance\n@variables α ω ω0 F t η x(t) # declare constant variables and a function x(t)\ndiff_eq = DifferentialEquation(d(x,t,2) + ω0^2*x + α*x^3 + η*d(x,t)*x^2 ~ F*cos(ω*t), x)\nadd_harmonic!(diff_eq, x, ω) # specify the ansatz x = u(T) cos(ωt) + v(T) sin(ωt)\n\n# implement ansatz to get harmonic equations\nharmonic_eq = get_harmonic_equations(diff_eq)\n\nfixed = (α => 1.0, ω0 => 1.0, F => 0.01, η => 0.1)   # fixed parameters\nvaried = ω => range(0.9, 1.2, 100)           # range of parameter values\nresult = get_steady_states(harmonic_eq, varied, fixed)","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"The results are shown:","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"A steady state result for 100 parameter points\n\nSolution branches:   3\n   of which real:    3\n   of which stable:  2\n\nClasses: stable, physical, Hopf, binary_labels","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"plot(result, \"sqrt(u1^2 + v1^2)\")","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/simple_Duffing/response_single.png\" alignment=\"center\" \\>","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"⠀","category":"page"},{"location":"#Documentation","page":"HarmonicBalance.jl","title":"Documentation","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"This documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"using Dates # hide\nprintln(\"Documentation built $(Dates.now()) with Julia $(VERSION)\") # hide","category":"page"}]
}
