var documenterSearchIndex = {"docs":
[{"location":"manual/plotting/#Analysis-and-plotting","page":"Analysis and plotting","title":"Analysis and plotting","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"The key method for visualization is transform_solutions, which parses a string into a symbolic expression and evaluates it for every steady state solution. ","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.transform_solutions","category":"page"},{"location":"manual/plotting/#HarmonicBalance.transform_solutions","page":"Analysis and plotting","title":"HarmonicBalance.transform_solutions","text":"transform_solutions(res::Result, f::String; rules) -> Any\n\n\nTakes a Result object and a string f representing a Symbolics.jl expression. Returns an array with the values of f evaluated for the respective solutions. Additional substitution rules can be specified in rules in the format (\"a\" => val) or (a => val)\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#Plotting-solutions","page":"Analysis and plotting","title":"Plotting solutions","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"Any function of the steady state solutions may be plotted.  In 1D, the solutions are colour-coded according to the branches obtained by sort_solutions. ","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.plot_1D_solutions\nHarmonicBalance.plot_1D_jacobian_eigenvalues\nHarmonicBalance.plot_2D_solutions","category":"page"},{"location":"manual/plotting/#HarmonicBalance.plot_1D_solutions","page":"Analysis and plotting","title":"HarmonicBalance.plot_1D_solutions","text":"plot_1D_solutions(res::Result; \n                    x::String, y::String, \n                    xscale=\"linear\",yscale=\"linear\"\n                    ,plot_only=[\"physical\"],\n                    marker_classification=\"stable\",filename=nothing, kwargs...)\n\nMake a 1D plot of a Result object.    \n\nKeyword arguments\n\nx, y: Expressions to plot on as independent/dependent variables (parsed into Symbolics.jl).\nxscale, yscale: scale for x/y dimensions (e.g. \"linear\" or \"log\")\nplot_only: a list of strings corresponding to the solution classes of Result. Only solutions which belong to the listed classes are plotted.\nmarker_classification: A class of the solutions (created by classify_solutions!) which is distinguished with different markers. Entering an inequality creates a new class \"custom_class\".\nfilename: if different from nothing, plotted data and parameter values are exported to ./filename.jld2. Otherwise, data is returned as a dictionary.\nkwargs: any additional keywords arguments for the matplotlib plotting\n\nThe strings in marker_classification allows the user to stablish custom criteria for binary classification of solutions. For instance, if marker_classification = \"ω^15* sqrt(u1^2 + v1^2) < 0.1\",  for a system with harmonic variables u1,v1, then solutions are classified as true according to that criterion and false according to its complement. \n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#HarmonicBalance.plot_1D_jacobian_eigenvalues","page":"Analysis and plotting","title":"HarmonicBalance.plot_1D_jacobian_eigenvalues","text":"plot_1D_jacobian_eigenvalues(res::Result; x::String, physical=true, stable=false,marker_re=\"o\",marker_im=\"X\", filename=nothing,kwargs...)\n\nMake a 1D plot of the Jacobian eigenvalues for each of the solutions in a Result object.\n\nKeyword arguments\n\nx: The function on the x axis (a string parsed into Symbolics.jl).\nphysical, stable: Booleans specifying whether unphysical and/or unstable solutions are shown.\nmarker_re, marker_im: The markers to use for the Re and Im parts of the eigenvalues.\nax: axis object from PyCall.PyObject setting the coordinate system where data will be plotted. If not given, it is created automatically.\nfilename: if different from nothing, plotted data and parameter values are exported to ./filename.jld2. Otherwise, data is returned as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#HarmonicBalance.plot_2D_solutions","page":"Analysis and plotting","title":"HarmonicBalance.plot_2D_solutions","text":"plot_2D_solutions(res::Result,ax=nothing; filename=nothing)\n\nMake a 2D plot of each of solutions vs swept parameters for a Result object, obtained from a get_steady_states applied to a 2D parameter grid.`.\n\nKeyword arguments\n\nax: axis object from PyCall.PyObject setting the coordinate system where data will be plotted. If not given, it is created automatically.\nfilename: if different from nothing, plotted data and parameter values are exported to ./filename.jld2.  Otherwise, data is returned as a dictionary.\nz: The function on the z axis (a string parsed into Symbolics.jl). If z=nothing, raw solutions are displayed\nplot_only: Array of labels to filter physical solutions (e.g. \"stable\") and multi-solution methods if z!=nothing (e.g. maximum)\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#Plotting-phase-diagrams-(2D)","page":"Analysis and plotting","title":"Plotting phase diagrams (2D)","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"In many problems, rather than in any property of the solutions themselves, we are interested in the phase diagrams, encoding the number of (stable) solutions in different regions of the parameter space. We provide functions to tackle solutions calculated over 2D parameter grids.","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.plot_2D_phase_diagram\nHarmonicBalance.plot_2D_phase_diagram_interactive","category":"page"},{"location":"manual/plotting/#HarmonicBalance.plot_2D_phase_diagram","page":"Analysis and plotting","title":"HarmonicBalance.plot_2D_phase_diagram","text":"plot_2D_phase_diagram(res::Result; stable=false,observable=\"nsols\",ax=nothing, filename=nothing)\n\nMake a 2D phase diagram plot of each of solutions vs swept parameters for a Result object, obtained from a get_steady_states applied to a 2D parameter grid.\n\nKeyword arguments \n\nstable: whether only stable solutions are depicted\nobservable: reference observable to represent dynamical phases in the problem. If observable=\"nsols\", number of solutions for each point is shown.   If instead observable=\"binary\", the result of classification of bistrings [is_stable(solution_1),is_stable(solution_2),...] is presented (see classify_binaries!(Result) function).\nfilename: if different from nothing, plotted data and parameter values are exported to ./filename.jld2.Otherwise, data is returned as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#HarmonicBalance.plot_2D_phase_diagram_interactive","page":"Analysis and plotting","title":"HarmonicBalance.plot_2D_phase_diagram_interactive","text":"plot_2D_phase_diagram_interactive(res::Result;\n observable=\"nsols\",\n  stable=false,nrows=2,\n  ncols=2,cut_dim=\"1\",\n  cut_type=\"solutions\",\n  string_f=nothing,\n  marker_classification=\"stable\")\n\nInteractive phase diagram of 2D solutions stored in Result.  This includes a clickable version of a plot_2D_phase_diagram for a given observable and extra panels containing 1D cuts of solutions, functions of solutions, or Jacobian eigenvalues.\n\nKeyword arguments \n\nobservable: reference observable to represent dynamical phases in the problem. If observable=\"nsols\", number of solutions for each point is shown.   If instead observable=\"binary\", the result of classification of bistrings[isstable(solution1),isstable(solution2),...]is presented (seeclassify_binaries!(Result)` function).\nncols, nrows: number of rows and columns of the plot window.\ncut_dim: dimension along which 1D quantities will be calculated. cut_dim=\"1\" (cut_dim=\"2\") takes a cut along the horizontal (vertical) parameter dimension of the 2D plot.\ncut_type: quantity to be represented along the 1D cut. If cut_type=solutions, steady state variables are shown with a panel per Problem variable.   Else if cut_type=jacobian eigenvalues, Re and Im parts of complex Jacobian eigenvalues for each solution are shown  with a panel per solution.    If instead cut_type=transform, functions of the solution variables passed to string_f (see below) are displayed.\nstring_f: list of strings for transformed observables to be plotted in 1D when cut_type=transform, e.g. string_f=[\"sqrt(u1^2 + v1^2)\",\"sqrt(u2^2 + v2^2)\"] for Problem variables u1,u2,v1,v2.\nmarker_classification: A class of the solutions (created by classify_solutions!) which is distinguished with different markers. Entering an inequality creates a new class \"custom_class\".\nylim: vertical limits for 1D cuts\n\n\n\n\n\n","category":"function"},{"location":"examples/ex1/#Example-1","page":"Example 1","title":"Example 1","text":"","category":"section"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"some text","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"markdown: ","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"using HarmonicBalance.jl","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"First, we need to define the symbolic variables to be used. The syntax here is inherited from Symbolics.jl","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"@variables","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"These are used to define an equation of motion","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"dEOM = HarmonicBalance.DifferentialEquation","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"This object now holds the equations and identifies its variables.","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"Now we must specify which harmonics will be used to expand which variable, let's start with using the single","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"HarmonicBalance.add_harmonic!(dEOM, x, ω)","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"The problem is now fully specified - we may convert the differential equation into a ","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"averagedEOM","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"We may now inspect the generated equations. The conversion has generated new variables describing each harmonic.","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"averagedEOM.equations","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"This object is the central point of the HarmonicBalance.jl framework. It may be fed into an algebraic or a time-dependent solver. ","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"averagedEOM","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"We are now ready to use the homotopy continuation method to obtain all the solutions of our algebraic equations. This is typically done across a set of parameters.","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"ParameterRange\nget_steady_states","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"So far, the equation have been relatively uncomplicated. However, due to the presence of the cubic nonlinearity, the ansatz ...      3ω does not fully describe the behaviour of our system. Frequency conversion - to first order, from ω to 3ω - will occur. To see the effect of this, we may expand the motion in both harmonics.","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"HarmonicBalance.add_harmonic!(dEOM, x, [ω, 3ω])","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"The generated equations are not perturbative - all harmonics are treated on the same footing. The newly generated variables are (pretty print of VDP types). Proceeding to a solution diagram as before, we may now plot the two harmonics separately.","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"We see that, although the third harmonic is clearly present, our solution landscape did not change much. In later examples, we will see this is not always the case. ","category":"page"},{"location":"examples/ex1/","page":"Example 1","title":"Example 1","text":"To sort: hyperlinks","category":"page"},{"location":"manual/solving_harmonics/#Solving-harmonic-equations","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"","category":"section"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Once a differential equation of motion has been defined in DifferentialEquation and converted to a HarmonicEquation, we may use the homotopy continuation method (as implemented in HomotopyContinuation.jl) to find steady states. This means that, having called get_harmonic_equations, we need to set all time-derivatives to zero and parse the resulting algebraic equations into a Problem.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Problem holds the steady-state equations, and (optionally) the symbolic Jacobian which is needed for stability / linear response calculations. ","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Once defined, a Problem can be solved for a set of input parameters using get_steady_states to obtain Result.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Problem\nget_steady_states\nResult","category":"page"},{"location":"manual/solving_harmonics/#HarmonicBalance.Problem","page":"Solving harmonic equations","title":"HarmonicBalance.Problem","text":"mutable struct Problem\n\nHolds a set of algebraic equations describing the steady state of a system.\n\nFields\n\nvariables::Vector{Symbolics.Num}\nThe harmonic variables to be solved for.\nparameters::Vector{Symbolics.Num}\nAll symbols which are not the harmonic variables.\nsystem::HomotopyContinuation.ModelKit.System\nThe input object for HomotopyContinuation.jl solver methods.\njacobian::Any\nThe Jacobian matrix (possibly symbolic).     If false, the Jacobian is ignored (may be calculated implicitly after solving).\neom::HarmonicEquation\nThe HarmonicEquation object used to generate this Problem.\n\nConstructors\n\nProblem(eom::HarmonicEquation; Jacobian=true) # find and store the symbolic Jacobian\nProblem(eom::HarmonicEquation; Jacobian=false) # ignore the Jacobian for now\nProblem(eom::HarmonicEquation; Jacobian::Matrix) # use the given matrix as the Jacobian\n\n\n\n\n\n","category":"type"},{"location":"manual/solving_harmonics/#HarmonicBalance.get_steady_states","page":"Solving harmonic equations","title":"HarmonicBalance.get_steady_states","text":"get_steady_states(prob::Problem, \n                    swept_parameters::ParameterRange,\n                    fixed_parameters::ParameterList;\n                    random_warmup=false,\n                        threading=false,\n                        sorting=\"hilbert\",\n                        show_progress=true)\n\nSolves prob over the ranges specified by swept_parameters, keeping fixed_parameters constant. swept_parameters accepts pairs mapping symbolic variables to arrays or LinRange. fixed_parameters accepts pairs mapping symbolic variables to numbers. \n\nKeyword arguments\n\nrandom_warmup: If true, a problem similar to prob but with random complex parameters is first solved to find all non-singular paths. The subsequent tracking to find results for all sweptparameters is then much faster than the initial solving. If `randomwarmup=false`, each parameter point is solved separately by tracking the maximum number of paths (employs a total degree homotopy).\n\nThis takes far longer but can be more reliable.\n\nthreading: If true, multithreaded support is activated. The number of available threads is set by the environment variable JULIA_NUM_THREADS. \nsorting: the method used by sort_solutions to get continuous solutions branches.  The current options are \"hilbert\" (1D sorting along a Hilbert curve), \"nearest\" (nearest-neighbor sorting) and \"none\".\nshow_progress: If true  Indicate whether a progress bar should be displayed (see HomotopyContinuation.jl docs \n\nExample: solving a simple harmonic oscillator m ddotx + γ dotx + ω_0^2 x = F cos(ωt) to obtain the response as a function of ω\n\n# having obtained a Problem object, let's find steady states\njulia> range = ParameterRange(ω => LinRange(0.8,1.2,100) ) # 100 parameter sets to solve\njulia> fixed = ParameterList(m => 1, γ => 0.01, F => 0.5, ω_0 => 1)\njulia> get_steady_states(problem, range, fixed)\n\nA steady state result for 100 parameter points\n\n    Solution branches:   1\n       of which real:    1\n       of which stable:  1\n    \n    Classes: stable, physical, Hopf, binary_labels\n    \n\nIt is also possible to create multi-dimensional solutions plots. \n\n# The swept parameters take precedence over fixed -> use the same fixed\njulia> range = ParameterRange(ω => LinRange(0.8,1.2,100), F => LinRange(0.1,1.0,10) ) # 100x10 parameter sets\n\n# The swept parameters take precedence over fixed -> the F in fixed is now ignored\njulia> get_steady_states(problem, range, fixed)\n\nA steady state result for 1000 parameter points\n\n    Solution branches:   1\n       of which real:    1\n       of which stable:  1\n    \n    Classes: stable, physical, Hopf, binary_labels\n\n\n\n\n\n","category":"function"},{"location":"manual/solving_harmonics/#HarmonicBalance.Result","page":"Solving harmonic equations","title":"HarmonicBalance.Result","text":"mutable struct Result\n\nStores the steady states of a HarmonicEquation.\n\nFields\n\nsolutions::Array{Vector{Vector{ComplexF64}}}\nThe variable values of steady-state solutions.\nswept_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Vector{Float64}}\nValues of all parameters for all solutions.\nfixed_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Float64}\nThe parameters fixed throughout the solutions.\nproblem::Problem\nThe Problem used to generate this.\nclasses::Dict{String, Array}\nMaps strings such as \"stable\", \"physical\" etc to arrays of values, classifying the solutions (see method classify_solutions!).\njacobian::Any\nThe Jacobian with fixed_parameters already substituted. Accepts a dictionary specifying the solution.     If problem.jacobian is a symbolic matrix, this holds a compiled function.     If problem.jacobian was false, this holds a function that rearranges the equations to find J     only after numerical values are inserted (preferable in cases where the symbolic J would be very large).\n\n\n\n\n\n","category":"type"},{"location":"manual/solving_harmonics/#Classifying-solutions","page":"Solving harmonic equations","title":"Classifying solutions","text":"","category":"section"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"The solutions in Result are accompanied by similarly-sized boolean arrays stored in the dictionary Result.classes. The classes can be used by the plotting functions to show/hide/label certain solutions.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"By default, classes \"physical\", \"stable\" and \"binary_labels\" are created. User-defined classification is possible with classify_solutions!.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"HarmonicBalance.classify_solutions!","category":"page"},{"location":"manual/solving_harmonics/#HarmonicBalance.classify_solutions!","page":"Solving harmonic equations","title":"HarmonicBalance.classify_solutions!","text":"classify_solutions!(res::Result, condition::String, name::String; physical) -> Any\n\n\nCreates a solution class in res using the inequality condition (parsed into Symbolics.jl input).\n\nThe new class is labelled with name and stored under res.classes[name].\n\nBy default, only physical (=real) solutions are classified, false is returned for the rest.\n\nExample\n\n# solve a previously-defined problem\nres = get_steady_states(problem, swept_parameters, fixed_parameters)\n\n# classify, store in result.classes[\"large_amplitude\"]\nclassify_solutions!(res, \"sqrt(u1^2 + v1^2) > 1.0\" , \"large_amplitude\")\n\n\n\n\n\n","category":"function"},{"location":"manual/solving_harmonics/#Sorting-solutions","page":"Solving harmonic equations","title":"Sorting solutions","text":"","category":"section"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Solving a steady-state problem over a range of parameters returns a solution set for each parameter. For a continuous change of parameters, each solution in a set usually also changes continuously; it is said to form a ''solution branch''. For an example, see the three colour-coded branches for the Duffing oscillator in Example 1.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"For stable states, the branches describe a system's behaviour under adiabatic parameter changes. ","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Therefore, after solving for a parameter range, we want to order each solution set such that the solutions' order reflects the branches.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"The function sort_solutions goes over the the raw output of get_steady_states and sorts each entry such that neighboring solution sets minimize Euclidean distance.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Currently, sort_solutions is compatible with 1D and 2D arrays of solution sets.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"HarmonicBalance.sort_solutions","category":"page"},{"location":"manual/solving_harmonics/#HarmonicBalance.sort_solutions","page":"Solving harmonic equations","title":"HarmonicBalance.sort_solutions","text":"sort_solutions(solutions::Array; sorting) -> Any\n\n\nSorts solutions into branches according to the method sorting.\n\nsolutions is an n-dimensional array of Vector{Vector}. Each element describes a set of solutions for a given parameter set. The output is a similar array, with each solution set rearranged such that neighboring solution sets have the smallest Euclidean distance.\n\n\n\n\n\n","category":"function"},{"location":"examples/ex2/#Example-2","page":"Example 2","title":"Example 2","text":"","category":"section"},{"location":"manual/entering_eom/#Entering-equations-of-motion","page":"Entering equations of motion","title":"Entering equations of motion","text":"","category":"section"},{"location":"manual/entering_eom/","page":"Entering equations of motion","title":"Entering equations of motion","text":"The struct DifferentialEquation is the primary input method; it holds an ODE or a coupled system of ODEs composed of terms with harmonic time-dependence The dependent variables are specified during input, any other symbols are identified as parameters. Information on which variable is to be expanded in which harmonic is specified using add_harmonic!. ","category":"page"},{"location":"manual/entering_eom/","page":"Entering equations of motion","title":"Entering equations of motion","text":"DifferentialEquation.equations stores a dictionary assigning variables to equations. This information is necessary because the harmonics belonging to a variable are later used to Fourier-transform its corresponding ODE.","category":"page"},{"location":"manual/entering_eom/","page":"Entering equations of motion","title":"Entering equations of motion","text":"DifferentialEquation\nadd_harmonic!\nget_variables(::DifferentialEquation)\nget_independent_variables(::DifferentialEquation)","category":"page"},{"location":"manual/entering_eom/#HarmonicBalance.DifferentialEquation","page":"Entering equations of motion","title":"HarmonicBalance.DifferentialEquation","text":"mutable struct DifferentialEquation\n\nHolds differential equation(s) of motion and a set of harmonics to expand each variable. This is the primary input for HarmonicBalance.jl ; after inputting the equations, the harmonics     ansatz needs to be specified using add_harmonic!.\n\nFields\n\nequations::OrderedCollections.OrderedDict{Symbolics.Num, Symbolics.Equation}\nAssigns to each variable an equation of motion.\nharmonics::OrderedCollections.OrderedDict{Symbolics.Num, Vector{Symbolics.Num}}\nAssigns to each variable a set of harmonics.\n\nExample\n\njulia> @variables t, x(t), y(t), ω0, ω, F, k;\n\n# equivalent ways to enter the simple harmonic oscillator\njulia> DifferentialEquation(d(x,t,2) + ω0^2 * x - F * cos(ω*t), x);\njulia> DifferentialEquation(d(x,t,2) + ω0^2 * x ~ F * cos(ω*t), x);\n\n# two coupled oscillators, one of them driven\njulia> DifferentialEquation([d(x,t,2) + ω0^2 * x - k*y, d(y,t,2) + ω0^2 * y - k*x] .~ [F * cos(ω*t), 0], [x,y]);\n\n\n\n\n\n","category":"type"},{"location":"manual/entering_eom/#HarmonicBalance.add_harmonic!","page":"Entering equations of motion","title":"HarmonicBalance.add_harmonic!","text":"add_harmonic!(diff_eom::DifferentialEquation, var::Symbolics.Num, ω) -> DifferentialEquation\n\n\nAdd the harmonic ω to the harmonic ansatz used to expand the variable var in diff_eom.\n\nExample\n\ndefine the simple harmonic oscillator and specify that x(t) oscillates with frequency ω\n\njulia> @variables t, x(t), y(t), ω0, ω, F, k;\njulia> diff_eq = DifferentialEquation(d(x,t,2) + ω0^2 * x ~ F * cos(ω*t), x);\njulia> add_harmonic!(diff_eq, x, ω) # expand x using ω\n\nSystem of 1 differential equations\nVariables:       x(t)\nHarmonic ansatz: x(t) => ω;   \n\n(ω0^2)*x(t) + Differential(t)(Differential(t)(x(t))) ~ F*cos(t*ω)\n\n\n\n\n\n","category":"function"},{"location":"manual/entering_eom/#Symbolics.get_variables-Tuple{DifferentialEquation}","page":"Entering equations of motion","title":"Symbolics.get_variables","text":"get_variables(diff_eom::DifferentialEquation) -> Vector{Symbolics.Num}\n\n\nReturn the dependent variables of diff_eom.\n\n\n\n\n\n","category":"method"},{"location":"manual/entering_eom/#HarmonicBalance.get_independent_variables-Tuple{DifferentialEquation}","page":"Entering equations of motion","title":"HarmonicBalance.get_independent_variables","text":"get_independent_variables(diff_eom::DifferentialEquation) -> Any\n\n\nReturn the independent dependent variables of diff_eom.\n\n\n\n\n\n","category":"method"},{"location":"manual/linear_response/#Linear-response","page":"Linear response","title":"Linear response","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"This module currently has two goals. One is calculating the Jacobian, used to obtain stability and approximate (but inexpensive) the linear response of steady states. The other is calculating the full response matrix as a function of frequency; this is more accurate but more expensive. ","category":"page"},{"location":"manual/linear_response/#Stability-and-response-from-the-Jacobian","page":"Linear response","title":"Stability and response from the Jacobian","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"The simplest way to extract the linear response of a steady state is to evaluate the Jacobian of the harmonic equations. Each of its eigenvalues lambda describes a Lorentzian peak in the response; textRelambda gives its center and textImlambda its width. Transforming the harmonic variables into the non-rotating frame (that is, inverting the harmonic ansatz) then gives the response as it would be observed in an experiment.","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"The advantage of this method is that for a given parameter set, only one matrix diagonalization is needed to fully describe the response spectrum. However, the method is inaccurate for response frequencies far from the frequencies used in the harmonic ansatz (it relies on the response oscillating slowly in the rotating frame). ","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"The Jacobian is also used to evaluate stability of the solutions.","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"HarmonicBalance.get_Jacobian\nHarmonicBalance.plot_jacobian_spectrum","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.get_Jacobian","page":"Linear response","title":"HarmonicBalance.LinearResponse.get_Jacobian","text":"get_Jacobian(eom)\n\n\nObtain the symbolic Jacobian matrix of eom (either a HarmonicEquation or a DifferentialEquation).\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.plot_jacobian_spectrum","page":"Linear response","title":"HarmonicBalance.LinearResponse.plot_jacobian_spectrum","text":"plot_jacobian_spectrum(res::Result,\n nat_var::Num;\n  Ω_range,\n   branch::Int,\n    y_offset::String=\"0.0\",\n     y_center::Float64=0.0,\n      x_scale=1.0,\n       y_scale=1.0,\n        logscale=false)\n\nMake a 1D plot of the response spectrum of res for the natural variable nat_var. Performs one matrix diagonalization for each element of Ω_range. This method is faster than plot_response but results in errors where the noise frequency is far from the frequency of the harmonic variables.\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"Behind the scenes, the spectra are stored using the dedicated structs Lorentzian and JacobianSpectrum.","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"HarmonicBalance.LinearResponse.JacobianSpectrum\nHarmonicBalance.LinearResponse.Lorentzian","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.JacobianSpectrum","page":"Linear response","title":"HarmonicBalance.LinearResponse.JacobianSpectrum","text":"mutable struct JacobianSpectrum\n\nHolds a set of Lorentzian objects belonging to a variable.\n\nFields\n\npeaks::Vector{HarmonicBalance.LinearResponse.Lorentzian}\n\nConstructor\n\nJacobianSpectrum(res::Result; index::Int, branch::Int)\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.Lorentzian","page":"Linear response","title":"HarmonicBalance.LinearResponse.Lorentzian","text":"struct Lorentzian\n\nHolds the three parameters of a Lorentzian peak, defined as A / sqrt((ω-ω0)² + Γ²).\n\nFields\n\nω0::Float64\nΓ::Float64\nA::Float64\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_response/#The-full-response-matrix","page":"Linear response","title":"The full response matrix","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"To recover the response spectra accurately. Unlike for the Jacobian, here we must evaluate in every point. ","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"HarmonicBalance.LinearResponse.ResponseMatrix\nHarmonicBalance.get_response\nHarmonicBalance.LinearResponse.get_response_matrix\nHarmonicBalance.plot_response","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.ResponseMatrix","page":"Linear response","title":"HarmonicBalance.LinearResponse.ResponseMatrix","text":"struct ResponseMatrix\n\nHolds the compiled response matrix of a system.\n\nFields\n\nmatrix::Matrix{Function}\nThe response matrix (compiled).\nsymbols::Vector{Symbolics.Num}\nAny symbolic variables in matrix to be substituted at evaluation.\nωs::Vector{Symbolics.Num}\nThe frequencies of the harmonic variables underlying matrix. These are needed to transform the harmonic variables to the non-rotating frame.\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.get_response","page":"Linear response","title":"HarmonicBalance.LinearResponse.get_response","text":"get_response(rmat::HarmonicBalance.LinearResponse.ResponseMatrix, s::Dict{Symbolics.Num, ComplexF64}, Ω) -> Any\n\n\nFor rmat and a solution dictionary s, calculate the total response to a perturbative force at frequency Ω.\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.get_response_matrix","page":"Linear response","title":"HarmonicBalance.LinearResponse.get_response_matrix","text":"get_response_matrix(diff_eq::DifferentialEquation, freq::Num; order=2)\n\nObtain the symbolic linear response matrix of a diff_eq corresponding to a perturbation frequency freq. This routine cannot accept a HarmonicEquation since there, some time-derivatives are already dropped. order denotes the highest differential order to be considered.\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.plot_response","page":"Linear response","title":"HarmonicBalance.LinearResponse.plot_response","text":"plot_response(res::Result, Ω_range; branch, logscale)\n\n\nPlot the linear response of a solution branch of res for the frequencies Ω_range.\n\nThis method takes n^2 matrix inversions for n elements of Ω_range. It therefore takes longer than plot_jacobian_spectrum (which is (O(n))) but is also valid far from resonance. \n\n\n\n\n\n","category":"function"},{"location":"manual/time_dependent/#Time-evolution","page":"Time evolution","title":"Time evolution","text":"","category":"section"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"Generally, solving the ODE of oscillatory systems in time requires numerically tracking the oscillations. This is a computationally expensive process; however, using the harmonic ansatz removes the oscillatory time-dependence. Simulating instead the harmonic variables of a HarmonicEquation is vastly more efficient - a steady state of the system appears as a fixed point in multidimensional space rather than an oscillatory function.","category":"page"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"The module TimeEvolution is used to interface HarmonicEquation with the powerful solvers contained in DifferentialEquations.jl. Time-dependent parameter sweeps are  defined using the object ParameterSweep.","category":"page"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"HarmonicBalance.TimeEvolution.ODEProblem\nHarmonicBalance.TimeEvolution.ParameterSweep","category":"page"},{"location":"manual/time_dependent/#HarmonicBalance.TimeEvolution.ODEProblem","page":"Time evolution","title":"HarmonicBalance.TimeEvolution.ODEProblem","text":"ODEProblem(\n        eom::HarmonicEquation;\n        fixed_parameters,\n        x0::Vector,\n        steady_solution::Dict\n        sweep::ParameterSweep,\n        timespan::Tuple\n        )\n\nCreates an ODEProblem object used by DifferentialEquations.jl from the equations in eom to simulate time-evolution within timespan. To manually input parameter values and initial conditions, use the keywords fixed_parameters and x0. To start the evolution from a steady-state solution, use steady_solution.\n\n\n\n\n\n","category":"function"},{"location":"manual/time_dependent/#HarmonicBalance.TimeEvolution.ParameterSweep","page":"Time evolution","title":"HarmonicBalance.TimeEvolution.ParameterSweep","text":"Represents a sweep of one or more parameters of a HarmonicEquation. During a sweep, the selected parameters vary linearly over some timespan and are constant elsewhere.\n\nSweeps of different variables can be combined using +.\n\nFields\n\nfunctions::Dict{Symbolics.Num, Function}\nMaps each swept parameter to a function.\n\nExamples\n\n# create a sweep of parameter a from 0 to 1 over time 0 -> 100\njulia> @variables a,b;\njulia> sweep = ParameterSweep(a => [0., 1.], (0, 100));\njulia> sweep[a](50)\n0.5\njulia> sweep[a](200)\n1.0\n\n# do the same, varying two parameters simultaneously\njulia> sweep = ParameterSweep([a => [0.,1.], b => [0., 1.]], (0,100))\n\n\n\n\n\n","category":"type"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"Using a time-dependent simulation can verify solution stability in cases where the Jacobian is too expensive to compute.","category":"page"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"HarmonicBalance.TimeEvolution.is_stable","category":"page"},{"location":"manual/time_dependent/#HarmonicBalance.TimeEvolution.is_stable","page":"Time evolution","title":"HarmonicBalance.TimeEvolution.is_stable","text":"is_stable(soln::Dict{Symbolics.Num, ComplexF64}, eom::HarmonicEquation; timespan, tol, perturb_initial)\n\n\nNumerically investigate the stability of a solution soln of eom within timespan. The initial condition is displaced by perturb_initial.\n\nReturn true the solution evolves within tol of the initial value (interpreted as stable).\n\n\n\n\n\n","category":"function"},{"location":"#HarmonicBalance.jl","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"HarmonicBalance.jl is a Julia package for solving nonlinear differential equations using the method of harmonic balance.","category":"page"},{"location":"#Installation","page":"HarmonicBalance.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"To install HarmonicBalance.jl, you can use the github repo https://github.com/NonlinearOscillations/HarmonicBalance.jl or the Julia package manager,","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"using Pkg\nPkg.add(\"HarmonicBalance\")","category":"page"},{"location":"#Citation","page":"HarmonicBalance.jl","title":"Citation","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"If you use HarmonicBalance.jl in your project, we kindly ask you to cite this paper:","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"@article{}\n}","category":"page"},{"location":"manual/extracting_harmonics/#Extracting-harmonic-equations","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"","category":"section"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"Once a DifferentialEquation is defined and its harmonics specified, one can extract the harmonic equations using get_harmonic_equations, which itself is composed of the subroutines harmonic_ansatz, slow_flow, fourier_transform! and drop_powers. ","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"The harmonic equations use an additional time variable specified as slow_time in get_harmonic_equations. This is essentially a label distinguishing the time dependence of the harmonic variables (expected to be slow) from that of the oscillating terms (expeted to be fast). When the equations are Fourier-transformed to remove oscillating terms, slow_time is treated as a constant. Such an approach is exact when looking for steady states. ","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"get_harmonic_equations\nHarmonicBalance.harmonic_ansatz\nHarmonicBalance.slow_flow\nHarmonicBalance.fourier_transform\nHarmonicBalance.drop_powers","category":"page"},{"location":"manual/extracting_harmonics/#HarmonicBalance.get_harmonic_equations","page":"Extracting harmonic equations","title":"HarmonicBalance.get_harmonic_equations","text":"get_harmonic_equations(diff_eom::DifferentialEquation; fast_time=nothing, slow_time=nothing)\n\nApply the harmonic ansatz, followed by the slow-flow, Fourier transform and dropping  higher-order derivatives to obtain a set of ODEs (the harmonic equations) governing the harmonics of diff_eom.\n\nThe harmonics evolve in slow_time, the oscillating terms themselves in fast_time. If no input is used, a variable T is defined for slow_time and fast_time is taken as the independent variable of diff_eom.\n\nBy default, all products of order > 1 of slow_time-derivatives are dropped, which means the equations are linear in the time-derivatives.\n\nExample\n\njulia> @variables t, x(t), ω0, ω, F;\n\n# enter the simple harmonic oscillator\njulia> diff_eom = DifferentialEquation( d(x,t,2) + ω0^2 * x ~ F *cos(ω*t), x);\n\n# expand x in the harmonic ω\njulia> add_harmonic!(diff_eom, x, ω);\n\n# get equations for the harmonics evolving in the slow time T\njulia> harmonic_eom = get_harmonic_equations(diff_eom)\n\nA set of 2 harmonic equations\nVariables: u1(T), v1(T)\nParameters: ω0, ω, F\n\nHarmonic ansatz: \nx(t) = u1*cos(ωt) + v1*sin(ωt)\n\nHarmonic equations:\n\n(ω0^2)*u1(T) + (2//1)*ω*Differential(T)(v1(T)) - (ω^2)*u1(T) ~ F\n\n(ω0^2)*v1(T) - (ω^2)*v1(T) - (2//1)*ω*Differential(T)(u1(T)) ~ 0\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.harmonic_ansatz","page":"Extracting harmonic equations","title":"HarmonicBalance.harmonic_ansatz","text":"harmonic_ansatz(eom::DifferentialEquation, time::Num; coordinates=\"Cartesian\")\n\nExpand each variable of diff_eom using the harmonics assigned to it with time as the time variable. For each harmonic of each variable, an instance of HarmonicVariable (describing a pair of variables (u,v)) is automatically created and named. \n\ncoordinates allows for using different coordinate systems (e.g. 'polars') - CURRENTLY INACTIVE\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.slow_flow","page":"Extracting harmonic equations","title":"HarmonicBalance.slow_flow","text":"slow_flow(eom::HarmonicEquation; fast_time::Num, slow_time::Num, degree=2)\n\nRemoves all derivatives w.r.t fast_time (and their products) in eom of power degree. In the remaining derivatives, fast_time is replaced by slow_time.\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.fourier_transform","page":"Extracting harmonic equations","title":"HarmonicBalance.fourier_transform","text":"fourier_transform(eom::HarmonicEquation, time::Symbolics.Num) -> HarmonicEquation\n\n\nExtract the Fourier components of eom corresponding to the harmonics specified in eom.variables. For each harmonic of each variable, 2 equations are generated (cos and sin Fourier coefficients). time does not appear in the resulting equations anymore.\n\nUnderlying assumption: all time-dependences are harmonic.\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.drop_powers","page":"Extracting harmonic equations","title":"HarmonicBalance.drop_powers","text":"drop_powers(expr, vars, deg)\n\n\nRemove parts of expr where the combined power of vars is => deg.\n\nExample\n\njulia> @variables x,y;\njulia>drop_powers((x+y)^2, x, 2)\ny^2 + 2*x*y\njulia>drop_powers((x+y)^2, [x,y], 2)\n0\njulia>drop_powers((x+y)^2 + (x+y)^3, [x,y], 3)\nx^2 + y^2 + 2*x*y\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicVariable-and-HarmonicEquation-types","page":"Extracting harmonic equations","title":"HarmonicVariable and HarmonicEquation types","text":"","category":"section"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"The equations governing the harmonics are stored using the two following structs. When going from the original to the harmonic equations, the harmonic ansatz x_i(t) = sum_j=1^M u_ij  (T)  cos(omega_ij t)+ v_ij(T) sin(omega_ij t) is used. Internally, each pair (u_ij v_ij) is stored as a HarmonicVariable. This includes the identification of omega_ij and x_i(t), which is needed to later reconstruct x_i(t).","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"HarmonicVariable","category":"page"},{"location":"manual/extracting_harmonics/#HarmonicBalance.HarmonicVariable","page":"Extracting harmonic equations","title":"HarmonicBalance.HarmonicVariable","text":"mutable struct HarmonicVariable\n\nHolds a pair of variables stored under symbols describing the harmonic ω of natural_variable. \n\nFields\n\nsymbols::Vector{Symbolics.Num}\nSymbols of the two variables in the HarmonicBalance namespace.\nnames::Dict{Symbolics.Num, String}\nHuman-readable labels of the two variables, used for plotting.\ntypes::Vector{String}\nTypes of the two variables ((u,v) for quadratures, (a,ϕ) for polars etc.)\nω::Symbolics.Num\nThe harmonic being described.\nnatural_variable::Symbolics.Num\nThe natural variable whose harmonic is being described.\n\n\n\n\n\n","category":"type"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"When the full set of equations of motion is expanded using the harmonic ansatz, the result is stored as a HarmonicEquation. For an initial equation of motion consisting of M variables, each expanded in N harmonics, the resulting HarmonicEquation holds 2NM equations of 2NM variables. Each symbol not corresponding to a variable is identified as a parameter. ","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"A HarmonicEquation can be either parsed into a steady-state Problem or solved using a dynamical ODE solver.","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"HarmonicEquation","category":"page"},{"location":"manual/extracting_harmonics/#HarmonicBalance.HarmonicEquation","page":"Extracting harmonic equations","title":"HarmonicBalance.HarmonicEquation","text":"mutable struct HarmonicEquation\n\nHolds a set of algebraic equations governing the harmonics of a DifferentialEquation.\n\nFields\n\nequations::Vector{Symbolics.Equation}\nA set of equations governing the harmonics.\nvariables::Vector{HarmonicVariable}\nA set of variables describing the harmonics.\nparameters::Vector{Symbolics.Num}\nThe parameters of the equation set.\nnatural_equation::DifferentialEquation\nThe natural equation (before the harmonic ansatz was used).\n\n\n\n\n\n","category":"type"},{"location":"manual/saving/#Saving-and-loading","page":"Saving and loading","title":"Saving and loading","text":"","category":"section"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"All of the types native to HarmonicBalance.jl can be saved into a .jld2 file using save and loaded using load. Most of the saving/loading is performed using the package JLD2.jl, with the addition of reinstating the symbolic variables in the HarmonicBalance namespace (needed to parse expressions used in the plotting functions) and recompiling stored functions (needed to evaluate Jacobians). As a consequence, composite objects such as Result can be saved and loaded with no loss of information.","category":"page"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"HarmonicBalance.save\nHarmonicBalance.load","category":"page"},{"location":"manual/saving/#HarmonicBalance.save","page":"Saving and loading","title":"HarmonicBalance.save","text":"save(filename, object)\n\n\nSaves object into .jld2 file filename (the suffix is added automatically if not entered). The resulting file contains a dictionary with a single entry.\n\n\n\n\n\n","category":"function"},{"location":"manual/saving/#HarmonicBalance.load","page":"Saving and loading","title":"HarmonicBalance.load","text":"load(filename)\n\n\nLoads an object from filename. For objects containing symbolic expressions such as HarmonicEquation, the symbolic variables are reinstated in the HarmonicBalance namespace.\n\n\n\n\n\n","category":"function"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"","category":"page"}]
}
