{
  "version": 3,
  "sources": ["../src/index.js", "../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js", "../node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/subclass.js", "../node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/utils-internals.js", "../node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/atomic.js"],
  "sourcesContent": ["import {Context, forEachUnescaped, getGroupContents, hasUnescaped, replaceUnescaped} from 'regex-utilities';\nimport {emulationGroupMarker} from 'regex/internals';\n\nconst r = String.raw;\nconst gRToken = r`\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;\nconst recursiveToken = r`\\(\\?R=(?<rDepth>[^\\)]+)\\)|${gRToken}`;\nconst namedCapturingDelim = r`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst token = new RegExp(r`${namedCapturingDelim}|${recursiveToken}|\\(\\?|\\\\?.`, 'gsu');\nconst overlappingRecursionMsg = 'Cannot use multiple overlapping recursions';\n// Support emulation groups with transfer marker prefix\nconst emulationGroupMarkerRe = new RegExp(r`(?:\\$[1-9]\\d*)?${emulationGroupMarker.replace(/\\$/g, r`\\$`)}`, 'y');\n\n/**\n@param {string} expression\n@param {{\n  flags?: string;\n  useEmulationGroups?: boolean;\n}} [data]\n@returns {string}\n*/\nexport function recursion(expression, data) {\n  // Keep the initial fail-check (which avoids unneeded processing) as fast as possible by testing\n  // without the accuracy improvement of using `hasUnescaped` with default `Context`\n  if (!(new RegExp(recursiveToken, 'su').test(expression))) {\n    return expression;\n  }\n  if (hasUnescaped(expression, r`\\(\\?\\(DEFINE\\)`, Context.DEFAULT)) {\n    throw new Error('DEFINE groups cannot be used with recursion');\n  }\n  const useEmulationGroups = !!data?.useEmulationGroups;\n  const hasNumberedBackref = hasUnescaped(expression, r`\\\\[1-9]`, Context.DEFAULT);\n  const groupContentsStartPos = new Map();\n  const openGroups = [];\n  let hasRecursed = false;\n  let numCharClassesOpen = 0;\n  let numCaptures = 0;\n  let match;\n  token.lastIndex = 0;\n  while ((match = token.exec(expression))) {\n    const {0: m, groups: {captureName, rDepth, gRNameOrNum, gRDepth}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n\n      // `(?R=N)`\n      if (rDepth) {\n        assertMaxInBounds(rDepth);\n        if (hasRecursed) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        if (hasNumberedBackref) {\n          // Could add support for numbered backrefs with extra effort, but it's probably not worth\n          // it. To trigger this error, the regex must include recursion and one of the following:\n          // - An interpolated regex that contains a numbered backref (since other numbered\n          //   backrefs are prevented by implicit flag n).\n          // - A numbered backref, when flag n is explicitly disabled.\n          // Note that Regex+'s extended syntax (atomic groups and sometimes subroutines) can also\n          // add numbered backrefs, but those work fine because external plugins like this one run\n          // *before* the transformation of built-in syntax extensions\n          throw new Error('Numbered backrefs cannot be used with global recursion');\n        }\n        const pre = expression.slice(0, match.index);\n        const post = expression.slice(token.lastIndex);\n        if (hasUnescaped(post, recursiveToken, Context.DEFAULT)) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        // No need to parse further\n        return makeRecursive(pre, post, +rDepth, false, useEmulationGroups);\n      // `\\g<name&R=N>`, `\\g<number&R=N>`\n      } else if (gRNameOrNum) {\n        assertMaxInBounds(gRDepth);\n        let isWithinReffedGroup = false;\n        for (const g of openGroups) {\n          if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {\n            isWithinReffedGroup = true;\n            if (g.hasRecursedWithin) {\n              throw new Error(overlappingRecursionMsg);\n            }\n            break;\n          }\n        }\n        if (!isWithinReffedGroup) {\n          throw new Error(r`Recursive \\g cannot be used outside the referenced group \"\\g<${gRNameOrNum}&R=${gRDepth}>\"`);\n        }\n        const startPos = groupContentsStartPos.get(gRNameOrNum);\n        const groupContents = getGroupContents(expression, startPos);\n        if (\n          hasNumberedBackref &&\n          hasUnescaped(groupContents, r`${namedCapturingDelim}|\\((?!\\?)`, Context.DEFAULT)\n        ) {\n          throw new Error('Numbered backrefs cannot be used with recursion of capturing groups');\n        }\n        const groupContentsPre = expression.slice(startPos, match.index);\n        const groupContentsPost = groupContents.slice(groupContentsPre.length + m.length);\n        const expansion = makeRecursive(groupContentsPre, groupContentsPost, +gRDepth, true, useEmulationGroups);\n        const pre = expression.slice(0, startPos);\n        const post = expression.slice(startPos + groupContents.length);\n        // Modify the string we're looping over\n        expression = `${pre}${expansion}${post}`;\n        // Step forward for the next loop iteration\n        token.lastIndex += expansion.length - m.length - groupContentsPre.length - groupContentsPost.length;\n        openGroups.forEach(g => g.hasRecursedWithin = true);\n        hasRecursed = true;\n      } else if (captureName) {\n        numCaptures++;\n        // NOTE: Not currently handling *named* emulation groups that already exist in the pattern\n        groupContentsStartPos.set(String(numCaptures), token.lastIndex);\n        groupContentsStartPos.set(captureName, token.lastIndex);\n        openGroups.push({\n          num: numCaptures,\n          name: captureName,\n        });\n      } else if (m.startsWith('(')) {\n        const isUnnamedCapture = m === '(';\n        if (isUnnamedCapture) {\n          numCaptures++;\n          groupContentsStartPos.set(\n            String(numCaptures),\n            token.lastIndex + (useEmulationGroups ? emulationGroupMarkerLength(expression, token.lastIndex) : 0)\n          );\n        }\n        openGroups.push(isUnnamedCapture ? {num: numCaptures} : {});\n      } else if (m === ')') {\n        openGroups.pop();\n      }\n\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n\n  return expression;\n}\n\n/**\n@param {string} max\n*/\nfunction assertMaxInBounds(max) {\n  const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;\n  if (!/^[1-9]\\d*$/.test(max)) {\n    throw new Error(errMsg);\n  }\n  max = +max;\n  if (max < 2 || max > 100) {\n    throw new Error(errMsg);\n  }\n}\n\n/**\n@param {string} pre\n@param {string} post\n@param {number} maxDepth\n@param {boolean} isSubpattern\n@param {boolean} useEmulationGroups\n@returns {string}\n*/\nfunction makeRecursive(pre, post, maxDepth, isSubpattern, useEmulationGroups) {\n  const namesInRecursed = new Set();\n  // Avoid this work if not needed\n  if (isSubpattern) {\n    forEachUnescaped(pre + post, namedCapturingDelim, ({groups: {captureName}}) => {\n      namesInRecursed.add(captureName);\n    }, Context.DEFAULT);\n  }\n  const reps = maxDepth - 1;\n  // Depth 2: 'pre(?:pre(?:)post)post'\n  // Depth 3: 'pre(?:pre(?:pre(?:)post)post)post'\n  return `${pre}${\n    repeatWithDepth(`(?:${pre}`, reps, (isSubpattern ? namesInRecursed : null), 'forward', useEmulationGroups)\n  }(?:)${\n    repeatWithDepth(`${post})`, reps, (isSubpattern ? namesInRecursed : null), 'backward', useEmulationGroups)\n  }${post}`;\n}\n\n/**\n@param {string} expression\n@param {number} reps\n@param {Set<string> | null} namesInRecursed\n@param {'forward' | 'backward'} direction\n@param {boolean} useEmulationGroups\n@returns {string}\n*/\nfunction repeatWithDepth(expression, reps, namesInRecursed, direction, useEmulationGroups) {\n  const startNum = 2;\n  const depthNum = i => direction === 'backward' ? reps - i + startNum - 1 : i + startNum;\n  let result = '';\n  for (let i = 0; i < reps; i++) {\n    const captureNum = depthNum(i);\n    result += replaceUnescaped(\n      expression,\n      // NOTE: Not currently handling *named* emulation groups that already exist in the pattern\n      r`${namedCapturingDelim}|\\\\k<(?<backref>[^>]+)>${\n        useEmulationGroups ? r`|(?<unnamed>\\()(?!\\?)(?:${emulationGroupMarkerRe.source})?` : ''\n      }`,\n      ({0: m, index, groups: {captureName, backref, unnamed}}) => {\n        if (backref && namesInRecursed && !namesInRecursed.has(backref)) {\n          // Don't alter backrefs to groups outside the recursed subpattern\n          return m;\n        }\n        // Only matches unnamed capture delim if `useEmulationGroups`\n        if (unnamed) {\n          // Add an emulation group marker, possibly replacing an existing marker (removes any\n          // transfer prefix)\n          return `(${emulationGroupMarker}`;\n        }\n        const suffix = `_$${captureNum}`;\n        return captureName ?\n          `(?<${captureName}${suffix}>${useEmulationGroups ? emulationGroupMarker : ''}` :\n          r`\\k<${backref}${suffix}>`;\n      },\n      Context.DEFAULT\n    );\n  }\n  return result;\n}\n\nfunction emulationGroupMarkerLength(expression, index) {\n  emulationGroupMarkerRe.lastIndex = index;\n  const match = emulationGroupMarkerRe.exec(expression);\n  return match ? match[0].length : 0;\n}\n", "// Constant properties for tracking regex syntax context\nexport const Context = Object.freeze({\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n});\n\n/**\nReplaces all unescaped instances of a regex pattern in the given context, using a replacement\nstring or callback.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {string | (match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => string} replacement\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {string} Updated expression\n@example\nconst str = '.\\\\.\\\\\\\\.[[\\\\.].].';\nreplaceUnescaped(str, '\\\\.', '@');\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.]@]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.DEFAULT);\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.].]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.CHAR_CLASS);\n// \u2192 '.\\\\.\\\\\\\\.[[\\\\.]@].'\n*/\nexport function replaceUnescaped(expression, needle, replacement, context) {\n  const re = new RegExp(String.raw`${needle}|(?<$skip>\\[\\^?|\\\\?.)`, 'gsu');\n  const negated = [false];\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const match of expression.matchAll(re)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match, {\n          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,\n          negated: negated[negated.length - 1],\n        });\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m[0] === '[') {\n      numCharClassesOpen++;\n      negated.push(m[1] === '^');\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n      negated.pop();\n    }\n    result += m;\n  }\n  return result;\n}\n\n/**\nRuns a callback for each unescaped instance of a regex pattern in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {(match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => void} callback\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n*/\nexport function forEachUnescaped(expression, needle, callback, context) {\n  // Do this the easy way\n  replaceUnescaped(expression, needle, callback, context);\n}\n\n/**\nReturns a match object for the first unescaped instance of a regex pattern in the given context, or\n`null`.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {number} [pos] Offset to start the search\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {RegExpExecArray | null}\n*/\nexport function execUnescaped(expression, needle, pos = 0, context) {\n  // Quick partial test; avoid the loop if not needed\n  if (!(new RegExp(needle, 'su').test(expression))) {\n    return null;\n  }\n  const re = new RegExp(`${needle}|(?<$skip>\\\\\\\\?.)`, 'gsu');\n  re.lastIndex = pos;\n  let numCharClassesOpen = 0;\n  let match;\n  while (match = re.exec(expression)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      return match;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    // Avoid an infinite loop on zero-length matches\n    if (re.lastIndex == match.index) {\n      re.lastIndex++;\n    }\n  }\n  return null;\n}\n\n/**\nChecks whether an unescaped instance of a regex pattern appears in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {boolean} Whether the pattern was found\n*/\nexport function hasUnescaped(expression, needle, context) {\n  // Do this the easy way\n  return !!execUnescaped(expression, needle, 0, context);\n}\n\n/**\nExtracts the full contents of a group (subpattern) from the given expression, accounting for\nescaped characters, nested groups, and character classes. The group is identified by the position\nwhere its contents start (the string index just after the group's opening delimiter). Returns the\nrest of the string if the group is unclosed.\n\nAssumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {number} contentsStartPos\n@returns {string}\n*/\nexport function getGroupContents(expression, contentsStartPos) {\n  const token = /\\\\?./gsu;\n  token.lastIndex = contentsStartPos;\n  let contentsEndPos = expression.length;\n  let numCharClassesOpen = 0;\n  // Starting search within an open group, after the group's opening\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token.exec(expression)) {\n    const [m] = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (m === '(') {\n        numGroupsOpen++;\n      } else if (m === ')') {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return expression.slice(contentsStartPos, contentsEndPos);\n}\n", "import {Context, replaceUnescaped} from 'regex-utilities';\n\n// This marker was chosen because it's impossible to match (so its extemely unlikely to be used in\n// a user-provided regex); it's not at risk of being optimized away, transformed, or flagged as an\n// error by a plugin; and it ends with an unquantifiable token\nconst emulationGroupMarker = '$E$';\n// Note: Emulation groups with transfer are also supported. They look like `($N$E$\u2026)` where `N` is\n// an integer 1 or greater. They're not used directly by Regex+ but can be used by plugins and\n// libraries that use Regex+ internals. Emulation groups with transfer are not only excluded from\n// match results, but additionally transfer their match to the group specified by `N`\n\n/**\nWorks the same as JavaScript's native `RegExp` constructor in all contexts, but automatically\nadjusts matches and subpattern indices (with flag `d`) to account for injected emulation groups.\n*/\nclass RegExpSubclass extends RegExp {\n  // Avoid `#private` to allow for subclassing\n  /**\n  @private\n  @type {Array<{\n    exclude: boolean;\n    transfer?: number;\n  }> | undefined}\n  */\n  _captureMap;\n  /**\n  @private\n  @type {Record<number, string> | undefined}\n  */\n  _namesByIndex;\n  /**\n  @param {string | RegExpSubclass} expression\n  @param {string} [flags]\n  @param {{useEmulationGroups: boolean;}} [options]\n  */\n  constructor(expression, flags, options) {\n    if (expression instanceof RegExp && options) {\n      throw new Error('Cannot provide options when copying a regexp');\n    }\n    const useEmulationGroups = !!options?.useEmulationGroups;\n    const unmarked = useEmulationGroups ? unmarkEmulationGroups(expression) : null;\n    super(unmarked?.expression || expression, flags);\n    // The third argument `options` isn't provided when regexes are copied as part of the internal\n    // handling of string methods `matchAll` and `split`\n    const src = useEmulationGroups ? unmarked : (expression instanceof RegExpSubclass ? expression : null);\n    if (src) {\n      this._captureMap = src._captureMap;\n      this._namesByIndex = src._namesByIndex;\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const match = RegExp.prototype.exec.call(this, str);\n    if (!match || !this._captureMap) {\n      return match;\n    }\n    const matchCopy = [...match];\n    // Empty all but the first value of the array while preserving its other properties\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    for (let i = 1; i < matchCopy.length; i++) {\n      if (this._captureMap[i].exclude) {\n        const transfer = this._captureMap[i].transfer;\n        if (transfer && match.length > transfer) {\n          match[transfer] = matchCopy[i];\n          const transferName = this._namesByIndex[transfer];\n          if (transferName) {\n            match.groups[transferName] = matchCopy[i];\n            if (this.hasIndices) {\n              match.indices.groups[transferName] = indicesCopy[i];\n            }\n          }\n          if (this.hasIndices) {\n            match.indices[transfer] = indicesCopy[i];\n          }\n        }\n      } else {\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n    }\n    return match;\n  }\n}\n\n/**\nBuild the capturing group map (with emulation groups marked to indicate their submatches shouldn't\nappear in results), and remove the markers for captures that were added to emulate extended syntax.\n@param {string} expression\n@returns {{\n  _captureMap: Array<{\n    exclude: boolean;\n    transfer?: number;\n  }>;\n  _namesByIndex: Record<number, string>;\n  expression: string;\n}}\n*/\nfunction unmarkEmulationGroups(expression) {\n  const marker = emulationGroupMarker.replace(/\\$/g, '\\\\$');\n  const _captureMap = [{exclude: false}];\n  const _namesByIndex = {0: ''};\n  let realCaptureNum = 0;\n  expression = replaceUnescaped(\n    expression,\n    String.raw`\\((?:(?!\\?)|\\?<(?![=!])(?<name>[^>]+)>)(?<mark>(?:\\$(?<transfer>[1-9]\\d*))?${marker})?`,\n    ({0: m, groups: {name, mark, transfer}}) => {\n      if (mark) {\n        _captureMap.push({\n          exclude: true,\n          transfer: transfer && +transfer,\n        });\n        return m.slice(0, -mark.length);\n      }\n      realCaptureNum++;\n      if (name) {\n        _namesByIndex[realCaptureNum] = name;\n      }\n      _captureMap.push({\n        exclude: false,\n      });\n      return m;\n    },\n    Context.DEFAULT\n  );\n  return {\n    _captureMap,\n    _namesByIndex,\n    expression,\n  };\n}\n\nexport {\n  emulationGroupMarker,\n  RegExpSubclass,\n};\n", "// Separating some utils for improved tree shaking of the `./internals` export\n\nconst noncapturingDelim = String.raw`\\(\\?(?:[:=!>A-Za-z\\-]|<[=!]|\\(DEFINE\\))`;\n\n/**\n@param {string} str\n@param {number} pos\n@param {string} oldValue\n@param {string} newValue\n@returns {string}\n*/\nfunction spliceStr(str, pos, oldValue, newValue) {\n  return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);\n}\n\nexport {\n  noncapturingDelim,\n  spliceStr,\n};\n", "import {emulationGroupMarker} from './subclass.js';\nimport {noncapturingDelim, spliceStr} from './utils-internals.js';\nimport {Context, replaceUnescaped} from 'regex-utilities';\n\nconst atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${noncapturingDelim})|(?<capturingStart>\\((?:\\?<[^>]+>)?)|\\\\?.`, 'gsu');\n\n/**\nApply transformations for atomic groups: `(?>\u2026)`.\n@param {string} expression\n@param {import('./regex.js').PluginData} [data]\n@returns {string}\n*/\nfunction atomic(expression, data) {\n  if (!/\\(\\?>/.test(expression)) {\n    return expression;\n  }\n  const aGDelim = '(?>';\n  const emulatedAGDelim = `(?:(?=(${data?.useEmulationGroups ? emulationGroupMarker : ''}`;\n  const captureNumMap = [0];\n  let numCapturesBeforeAG = 0;\n  let numAGs = 0;\n  let aGPos = NaN;\n  let hasProcessedAG;\n  do {\n    hasProcessedAG = false;\n    let numCharClassesOpen = 0;\n    let numGroupsOpenInAG = 0;\n    let inAG = false;\n    let match;\n    atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + emulatedAGDelim.length;\n    while (match = atomicPluginToken.exec(expression)) {\n      const {0: m, index, groups: {capturingStart, noncapturingStart}} = match;\n      if (m === '[') {\n        numCharClassesOpen++;\n      } else if (!numCharClassesOpen) {\n\n        if (m === aGDelim && !inAG) {\n          aGPos = index;\n          inAG = true;\n        } else if (inAG && noncapturingStart) {\n          numGroupsOpenInAG++;\n        } else if (capturingStart) {\n          if (inAG) {\n            numGroupsOpenInAG++;\n          } else {\n            numCapturesBeforeAG++;\n            captureNumMap.push(numCapturesBeforeAG + numAGs);\n          }\n        } else if (m === ')' && inAG) {\n          if (!numGroupsOpenInAG) {\n            numAGs++;\n            // Replace `expression` and use `<$$N>` as a temporary wrapper for the backref so it\n            // can avoid backref renumbering afterward. Need to wrap the whole substitution\n            // (including the lookahead and following backref) in a noncapturing group to handle\n            // following quantifiers and literal digits\n            expression = `${expression.slice(0, aGPos)}${emulatedAGDelim}${\n                expression.slice(aGPos + aGDelim.length, index)\n              }))<$$${numAGs + numCapturesBeforeAG}>)${expression.slice(index + 1)}`;\n            hasProcessedAG = true;\n            break;\n          }\n          numGroupsOpenInAG--;\n        }\n\n      } else if (m === ']') {\n        numCharClassesOpen--;\n      }\n    }\n  // Start over from the beginning of the last atomic group's contents, in case the processed group\n  // contains additional atomic groups\n  } while (hasProcessedAG);\n\n  // Second pass to adjust numbered backrefs\n  expression = replaceUnescaped(\n    expression,\n    String.raw`\\\\(?<backrefNum>[1-9]\\d*)|<\\$\\$(?<wrappedBackrefNum>\\d+)>`,\n    ({0: m, groups: {backrefNum, wrappedBackrefNum}}) => {\n      if (backrefNum) {\n        const bNum = +backrefNum;\n        if (bNum > captureNumMap.length - 1) {\n          throw new Error(`Backref \"${m}\" greater than number of captures`);\n        }\n        return `\\\\${captureNumMap[bNum]}`;\n      }\n      return `\\\\${wrappedBackrefNum}`;\n    },\n    Context.DEFAULT\n  );\n  return expression;\n}\n\nconst baseQuantifier = String.raw`(?:[?*+]|\\{\\d+(?:,\\d*)?\\})`;\n// Complete tokenizer for base syntax; doesn't (need to) know about character-class-only syntax\nconst possessivePluginToken = new RegExp(String.raw`\n\\\\(?: \\d+\n  | c[A-Za-z]\n  | [gk]<[^>]+>\n  | [pPu]\\{[^\\}]+\\}\n  | u[A-Fa-f\\d]{4}\n  | x[A-Fa-f\\d]{2}\n  )\n| \\((?: \\? (?: [:=!>]\n  | <(?:[=!]|[^>]+>)\n  | [A-Za-z\\-]+:\n  | \\(DEFINE\\)\n  ))?\n| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\\{]?)\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\nTransform posessive quantifiers into atomic groups. The posessessive quantifiers are:\n`?+`, `*+`, `++`, `{N}+`, `{N,}+`, `{N,N}+`.\nThis follows Java, PCRE, Perl, and Python.\nPossessive quantifiers in Oniguruma and Onigmo are only: `?+`, `*+`, `++`.\n@param {string} expression\n@returns {string}\n*/\nfunction possessive(expression) {\n  if (!(new RegExp(`${baseQuantifier}\\\\+`).test(expression))) {\n    return expression;\n  }\n  const openGroupIndices = [];\n  let lastGroupIndex = null;\n  let lastCharClassIndex = null;\n  let lastToken = '';\n  let numCharClassesOpen = 0;\n  let match;\n  possessivePluginToken.lastIndex = 0;\n  while (match = possessivePluginToken.exec(expression)) {\n    const {0: m, index, groups: {qBase, qMod, invalidQ}} = match;\n    if (m === '[') {\n      if (!numCharClassesOpen) {\n        lastCharClassIndex = index;\n      }\n      numCharClassesOpen++;\n    } else if (m === ']') {\n      if (numCharClassesOpen) {\n        numCharClassesOpen--;\n      // Unmatched `]`\n      } else {\n        lastCharClassIndex = null;\n      }\n    } else if (!numCharClassesOpen) {\n\n      if (qMod === '+' && lastToken && !lastToken.startsWith('(')) {\n        // Invalid following quantifier would become valid via the wrapping group\n        if (invalidQ) {\n          throw new Error(`Invalid quantifier \"${m}\"`);\n        }\n        let charsAdded = -1; // -1 for removed trailing `+`\n        // Possessivizing fixed repetition quantifiers like `{2}` does't change their behavior, so\n        // avoid doing so (convert them to greedy)\n        if (/^\\{\\d+\\}$/.test(qBase)) {\n          expression = spliceStr(expression, index + qBase.length, qMod, '');\n        } else {\n          if (lastToken === ')' || lastToken === ']') {\n            const nodeIndex = lastToken === ')' ? lastGroupIndex : lastCharClassIndex;\n            // Unmatched `)` would break out of the wrapping group and mess with handling.\n            // Unmatched `]` wouldn't be a problem, but it's unnecessary to have dedicated support\n            // for unescaped `]++` since this won't work with flag u or v anyway\n            if (nodeIndex === null) {\n              throw new Error(`Invalid unmatched \"${lastToken}\"`);\n            }\n            expression = `${expression.slice(0, nodeIndex)}(?>${expression.slice(nodeIndex, index)}${qBase})${expression.slice(index + m.length)}`;\n          } else {\n            expression = `${expression.slice(0, index - lastToken.length)}(?>${lastToken}${qBase})${expression.slice(index + m.length)}`;\n          }\n          charsAdded += 4; // `(?>)`\n        }\n        possessivePluginToken.lastIndex += charsAdded;\n      } else if (m[0] === '(') {\n        openGroupIndices.push(index);\n      } else if (m === ')') {\n        lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;\n      }\n\n    }\n    lastToken = m;\n  }\n  return expression;\n}\n\nexport {\n  atomic,\n  possessive,\n};\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "recursion", "Context", "replaceUnescaped", "expression", "needle", "replacement", "context", "re", "negated", "numCharClassesOpen", "result", "match", "m", "$skip", "forEachUnescaped", "callback", "execUnescaped", "pos", "hasUnescaped", "getGroupContents", "contentsStartPos", "token", "contentsEndPos", "numGroupsOpen", "emulationGroupMarker", "noncapturingDelim", "atomicPluginToken", "noncapturingDelim", "baseQuantifier", "possessivePluginToken", "r", "gRToken", "recursiveToken", "namedCapturingDelim", "token", "overlappingRecursionMsg", "emulationGroupMarkerRe", "emulationGroupMarker", "recursion", "expression", "data", "hasUnescaped", "Context", "useEmulationGroups", "hasNumberedBackref", "groupContentsStartPos", "openGroups", "hasRecursed", "numCharClassesOpen", "numCaptures", "match", "m", "captureName", "rDepth", "gRNameOrNum", "gRDepth", "assertMaxInBounds", "pre", "post", "makeRecursive", "isWithinReffedGroup", "g", "startPos", "groupContents", "getGroupContents", "groupContentsPre", "groupContentsPost", "expansion", "isUnnamedCapture", "emulationGroupMarkerLength", "max", "errMsg", "maxDepth", "isSubpattern", "namesInRecursed", "forEachUnescaped", "reps", "repeatWithDepth", "direction", "depthNum", "i", "result", "captureNum", "replaceUnescaped", "index", "backref", "unnamed", "suffix"]
}
