import{_ as l,C as p,c as h,o as k,ai as e,j as i,a,G as n}from"./chunks/framework.DDAOwcjc.js";const v=JSON.parse('{"title":"Time evolution","description":"","frontmatter":{},"headers":[],"relativePath":"manual/time_dependent.md","filePath":"manual/time_dependent.md"}'),r={name:"manual/time_dependent.md"},o={class:"jldocstring custom-block",open:""},d={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""};function y(u,s,m,b,F,C){const t=p("Badge");return k(),h("div",null,[s[15]||(s[15]=e("",3)),i("details",o,[i("summary",null,[s[0]||(s[0]=i("a",{id:"SciMLBase.ODEProblem-Tuple{HarmonicEquation, Any}-manual-time_dependent",href:"#SciMLBase.ODEProblem-Tuple{HarmonicEquation, Any}-manual-time_dependent"},[i("span",{class:"jlbinding"},"SciMLBase.ODEProblem")],-1)),s[1]||(s[1]=a()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[2]||(s[2]=e("",3))]),i("details",d,[i("summary",null,[s[3]||(s[3]=i("a",{id:"HarmonicBalance.AdiabaticSweep-manual-time_dependent",href:"#HarmonicBalance.AdiabaticSweep-manual-time_dependent"},[i("span",{class:"jlbinding"},"HarmonicBalance.AdiabaticSweep")],-1)),s[4]||(s[4]=a()),n(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[5]||(s[5]=e("",13))]),s[16]||(s[16]=i("p",null,[a("In addition, one can use the "),i("code",null,"steady_state_sweep"),a(" function from "),i("code",null,"SteadyStateDiffEqExt"),a(" to perform a parameter sweep over the steady states of a system. For this one has to load "),i("code",null,"SteadyStateDiffEq.jl"),a(".")],-1)),i("details",E,[i("summary",null,[s[6]||(s[6]=i("a",{id:"HarmonicBalance.steady_state_sweep-manual-time_dependent",href:"#HarmonicBalance.steady_state_sweep-manual-time_dependent"},[i("span",{class:"jlbinding"},"HarmonicBalance.steady_state_sweep")],-1)),s[7]||(s[7]=a()),n(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[8]||(s[8]=e("",6))]),s[17]||(s[17]=i("h2",{id:"plotting",tabindex:"-1"},[a("Plotting "),i("a",{class:"header-anchor",href:"#plotting","aria-label":'Permalink to "Plotting"'},"​")],-1)),i("details",c,[i("summary",null,[s[9]||(s[9]=i("a",{id:"RecipesBase.plot-Tuple{ODESolution, Any, HarmonicEquation}-manual-time_dependent",href:"#RecipesBase.plot-Tuple{ODESolution, Any, HarmonicEquation}-manual-time_dependent"},[i("span",{class:"jlbinding"},"RecipesBase.plot")],-1)),s[10]||(s[10]=a()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[11]||(s[11]=e("",10))]),s[18]||(s[18]=i("h2",{id:"miscellaneous",tabindex:"-1"},[a("Miscellaneous "),i("a",{class:"header-anchor",href:"#miscellaneous","aria-label":'Permalink to "Miscellaneous"'},"​")],-1)),s[19]||(s[19]=i("p",null,"Using a time-dependent simulation can verify solution stability in cases where the Jacobian is too expensive to compute.",-1)),i("details",g,[i("summary",null,[s[12]||(s[12]=i("a",{id:"HarmonicBalance.is_stable-manual-time_dependent",href:"#HarmonicBalance.is_stable-manual-time_dependent"},[i("span",{class:"jlbinding"},"HarmonicBalance.is_stable")],-1)),s[13]||(s[13]=a()),n(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[14]||(s[14]=e("",7))])])}const _=l(r,[["render",y]]);export{v as __pageData,_ as default};
