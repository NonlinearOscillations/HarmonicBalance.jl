var documenterSearchIndex = {"docs":
[{"location":"manual/plotting/#Analysis-and-plotting","page":"Analysis and plotting","title":"Analysis and plotting","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"The key method for visualization is transform_solutions, which parses a string into a symbolic expression and evaluates it for every steady state solution. ","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.transform_solutions","category":"page"},{"location":"manual/plotting/#HarmonicBalance.transform_solutions","page":"Analysis and plotting","title":"HarmonicBalance.transform_solutions","text":"transform_solutions(res::Result, f::String; rules) -> Any\n\n\nTakes a Result object and a string f representing a Symbolics.jl expression. Returns an array with the values of f evaluated for the respective solutions. Additional substitution rules can be specified in rules in the format (\"a\" => val) or (a => val)\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#Plotting-solutions","page":"Analysis and plotting","title":"Plotting solutions","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"Any function of the steady state solutions may be plotted.  In 1D, the solutions are colour-coded according to the branches obtained by sort_solutions. ","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.plot_1D_solutions\nHarmonicBalance.plot_1D_jacobian_eigenvalues\nHarmonicBalance.plot_2D_solutions","category":"page"},{"location":"manual/plotting/#HarmonicBalance.plot_1D_solutions","page":"Analysis and plotting","title":"HarmonicBalance.plot_1D_solutions","text":"plot_1D_solutions(res::Result; \n                    x::String, y::String, \n                    xscale=\"linear\",yscale=\"linear\"\n                    ,plot_only=[\"physical\"],\n                    marker_classification=\"stable\",filename=nothing, kwargs...)\n\nMake a 1D plot of a Result object.    \n\nKeyword arguments\n\nx, y: Expressions to plot on as independent/dependent variables (parsed into Symbolics.jl).\nxscale, yscale: scale for x/y dimensions (e.g. \"linear\" or \"log\")\nplot_only: a list of strings corresponding to the solution classes of Result. Only solutions which belong to the listed classes are plotted.\nmarker_classification: A class of the solutions (created by classify_solutions!) which is distinguished with different markers. Entering an inequality creates a new class \"custom_class\".\nfilename: if different from nothing, plotted data and parameter values are exported to ./filename.jld2. Otherwise, data is returned as a dictionary.\nkwargs: any additional keywords arguments for the matplotlib plotting\n\nThe strings in marker_classification allows the user to stablish custom criteria for binary classification of solutions. For instance, if marker_classification = \"ω^15* sqrt(u1^2 + v1^2) < 0.1\",  for a system with harmonic variables u1,v1, then solutions are classified as true according to that criterion and false according to its complement. \n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#HarmonicBalance.plot_1D_jacobian_eigenvalues","page":"Analysis and plotting","title":"HarmonicBalance.plot_1D_jacobian_eigenvalues","text":"plot_1D_jacobian_eigenvalues(res::Result; x::String, physical=true, stable=false,marker_re=\"o\",marker_im=\"X\", filename=nothing,kwargs...)\n\nMake a 1D plot of the Jacobian eigenvalues for each of the solutions in a Result object.\n\nKeyword arguments\n\nx: The function on the x axis (a string parsed into Symbolics.jl).\nphysical, stable: Booleans specifying whether unphysical and/or unstable solutions are shown.\nmarker_re, marker_im: The markers to use for the Re and Im parts of the eigenvalues.\nax: axis object from PyCall.PyObject setting the coordinate system where data will be plotted. If not given, it is created automatically.\nfilename: if different from nothing, plotted data and parameter values are exported to ./filename.jld2. Otherwise, data is returned as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#HarmonicBalance.plot_2D_solutions","page":"Analysis and plotting","title":"HarmonicBalance.plot_2D_solutions","text":"plot_2D_solutions(res::Result,ax=nothing; filename=nothing)\n\nMake a 2D plot of each of solutions vs swept parameters for a Result object, obtained from a get_steady_states applied to a 2D parameter grid.`.\n\nKeyword arguments\n\nax: axis object from PyCall.PyObject setting the coordinate system where data will be plotted. If not given, it is created automatically.\nfilename: if different from nothing, plotted data and parameter values are exported to ./filename.jld2.  Otherwise, data is returned as a dictionary.\nz: The function on the z axis (a string parsed into Symbolics.jl). If z=nothing, raw solutions are displayed\nplot_only: Array of labels to filter physical solutions (e.g. \"stable\") and multi-solution methods if z!=nothing (e.g. maximum)\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#Plotting-phase-diagrams-(2D)","page":"Analysis and plotting","title":"Plotting phase diagrams (2D)","text":"","category":"section"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"In many problems, rather than in any property of the solutions themselves, we are interested in the phase diagrams, encoding the number of (stable) solutions in different regions of the parameter space. We provide functions to tackle solutions calculated over 2D parameter grids.","category":"page"},{"location":"manual/plotting/","page":"Analysis and plotting","title":"Analysis and plotting","text":"HarmonicBalance.plot_2D_phase_diagram\nHarmonicBalance.plot_2D_phase_diagram_interactive","category":"page"},{"location":"manual/plotting/#HarmonicBalance.plot_2D_phase_diagram","page":"Analysis and plotting","title":"HarmonicBalance.plot_2D_phase_diagram","text":"plot_2D_phase_diagram(res::Result; stable=false,observable=\"nsols\",ax=nothing, filename=nothing)\n\nMake a 2D phase diagram plot of each of solutions vs swept parameters for a Result object, obtained from a get_steady_states applied to a 2D parameter grid.\n\nKeyword arguments \n\nstable: whether only stable solutions are depicted\nobservable: reference observable to represent dynamical phases in the problem. If observable=\"nsols\", number of solutions for each point is shown.   If instead observable=\"binary\", the result of classification of bistrings [is_stable(solution_1),is_stable(solution_2),...] is presented (see classify_binaries!(Result) function).\nfilename: if different from nothing, plotted data and parameter values are exported to ./filename.jld2.Otherwise, data is returned as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"manual/plotting/#HarmonicBalance.plot_2D_phase_diagram_interactive","page":"Analysis and plotting","title":"HarmonicBalance.plot_2D_phase_diagram_interactive","text":"plot_2D_phase_diagram_interactive(res::Result;\n observable=\"nsols\",\n  stable=false,nrows=2,\n  ncols=2,cut_dim=\"1\",\n  cut_type=\"solutions\",\n  string_f=nothing,\n  marker_classification=\"stable\")\n\nInteractive phase diagram of 2D solutions stored in Result.  This includes a clickable version of a plot_2D_phase_diagram for a given observable and extra panels containing 1D cuts of solutions, functions of solutions, or Jacobian eigenvalues.\n\nKeyword arguments \n\nobservable: reference observable to represent dynamical phases in the problem. If observable=\"nsols\", number of solutions for each point is shown.   If instead observable=\"binary\", the result of classification of bistrings[isstable(solution1),isstable(solution2),...]is presented (seeclassify_binaries!(Result)` function).\nncols, nrows: number of rows and columns of the plot window.\ncut_dim: dimension along which 1D quantities will be calculated. cut_dim=\"1\" (cut_dim=\"2\") takes a cut along the horizontal (vertical) parameter dimension of the 2D plot.\ncut_type: quantity to be represented along the 1D cut. If cut_type=solutions, steady state variables are shown with a panel per Problem variable.   Else if cut_type=jacobian eigenvalues, Re and Im parts of complex Jacobian eigenvalues for each solution are shown  with a panel per solution.    If instead cut_type=transform, functions of the solution variables passed to string_f (see below) are displayed.\nstring_f: list of strings for transformed observables to be plotted in 1D when cut_type=transform, e.g. string_f=[\"sqrt(u1^2 + v1^2)\",\"sqrt(u2^2 + v2^2)\"] for Problem variables u1,u2,v1,v2.\nmarker_classification: A class of the solutions (created by classify_solutions!) which is distinguished with different markers. Entering an inequality creates a new class \"custom_class\".\nylim: vertical limits for 1D cuts\n\n\n\n\n\n","category":"function"},{"location":"manual/entering_eom/#Entering-equations-of-motion","page":"Entering equations of motion","title":"Entering equations of motion","text":"","category":"section"},{"location":"manual/entering_eom/","page":"Entering equations of motion","title":"Entering equations of motion","text":"The struct DifferentialEquation is the primary input method; it holds an ODE or a coupled system of ODEs composed of terms with harmonic time-dependence The dependent variables are specified during input, any other symbols are identified as parameters. Information on which variable is to be expanded in which harmonic is specified using add_harmonic!. ","category":"page"},{"location":"manual/entering_eom/","page":"Entering equations of motion","title":"Entering equations of motion","text":"DifferentialEquation.equations stores a dictionary assigning variables to equations. This information is necessary because the harmonics belonging to a variable are later used to Fourier-transform its corresponding ODE.","category":"page"},{"location":"manual/entering_eom/","page":"Entering equations of motion","title":"Entering equations of motion","text":"DifferentialEquation\nadd_harmonic!\nget_variables(::DifferentialEquation)\nget_independent_variables(::DifferentialEquation)","category":"page"},{"location":"manual/entering_eom/#HarmonicBalance.DifferentialEquation","page":"Entering equations of motion","title":"HarmonicBalance.DifferentialEquation","text":"mutable struct DifferentialEquation\n\nHolds differential equation(s) of motion and a set of harmonics to expand each variable. This is the primary input for HarmonicBalance.jl ; after inputting the equations, the harmonics     ansatz needs to be specified using add_harmonic!.\n\nFields\n\nequations::OrderedCollections.OrderedDict{Symbolics.Num, Symbolics.Equation}\nAssigns to each variable an equation of motion.\nharmonics::OrderedCollections.OrderedDict{Symbolics.Num, Vector{Symbolics.Num}}\nAssigns to each variable a set of harmonics.\n\nExample\n\njulia> @variables t, x(t), y(t), ω0, ω, F, k;\n\n# equivalent ways to enter the simple harmonic oscillator\njulia> DifferentialEquation(d(x,t,2) + ω0^2 * x - F * cos(ω*t), x);\njulia> DifferentialEquation(d(x,t,2) + ω0^2 * x ~ F * cos(ω*t), x);\n\n# two coupled oscillators, one of them driven\njulia> DifferentialEquation([d(x,t,2) + ω0^2 * x - k*y, d(y,t,2) + ω0^2 * y - k*x] .~ [F * cos(ω*t), 0], [x,y]);\n\n\n\n\n\n","category":"type"},{"location":"manual/entering_eom/#HarmonicBalance.add_harmonic!","page":"Entering equations of motion","title":"HarmonicBalance.add_harmonic!","text":"add_harmonic!(diff_eom::DifferentialEquation, var::Symbolics.Num, ω) -> DifferentialEquation\n\n\nAdd the harmonic ω to the harmonic ansatz used to expand the variable var in diff_eom.\n\nExample\n\ndefine the simple harmonic oscillator and specify that x(t) oscillates with frequency ω\n\njulia> @variables t, x(t), y(t), ω0, ω, F, k;\njulia> diff_eq = DifferentialEquation(d(x,t,2) + ω0^2 * x ~ F * cos(ω*t), x);\njulia> add_harmonic!(diff_eq, x, ω) # expand x using ω\n\nSystem of 1 differential equations\nVariables:       x(t)\nHarmonic ansatz: x(t) => ω;   \n\n(ω0^2)*x(t) + Differential(t)(Differential(t)(x(t))) ~ F*cos(t*ω)\n\n\n\n\n\n","category":"function"},{"location":"manual/entering_eom/#Symbolics.get_variables-Tuple{DifferentialEquation}","page":"Entering equations of motion","title":"Symbolics.get_variables","text":"get_variables(diff_eom::DifferentialEquation) -> Vector{Symbolics.Num}\n\n\nReturn the dependent variables of diff_eom.\n\n\n\n\n\n","category":"method"},{"location":"manual/entering_eom/#HarmonicBalance.get_independent_variables-Tuple{DifferentialEquation}","page":"Entering equations of motion","title":"HarmonicBalance.get_independent_variables","text":"get_independent_variables(diff_eom::DifferentialEquation) -> Any\n\n\nReturn the independent dependent variables of diff_eom.\n\n\n\n\n\n","category":"method"},{"location":"manual/time_dependent/#Time-evolution","page":"Time evolution","title":"Time evolution","text":"","category":"section"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"Generally, solving the ODE of oscillatory systems in time requires numerically tracking the oscillations. This is a computationally expensive process; however, using the harmonic ansatz removes the oscillatory time-dependence. Simulating instead the harmonic variables of a HarmonicEquation is vastly more efficient - a steady state of the system appears as a fixed point in multidimensional space rather than an oscillatory function.","category":"page"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"The module TimeEvolution is used to interface HarmonicEquation with the powerful solvers contained in DifferentialEquations.jl. Time-dependent parameter sweeps are  defined using the object ParameterSweep.","category":"page"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"HarmonicBalance.TimeEvolution.ODEProblem\nHarmonicBalance.TimeEvolution.ParameterSweep","category":"page"},{"location":"manual/time_dependent/#HarmonicBalance.TimeEvolution.ODEProblem","page":"Time evolution","title":"HarmonicBalance.TimeEvolution.ODEProblem","text":"ODEProblem(\n        eom::HarmonicEquation;\n        fixed_parameters,\n        x0::Vector,\n        steady_solution::Dict\n        sweep::ParameterSweep,\n        timespan::Tuple\n        )\n\nCreates an ODEProblem object used by DifferentialEquations.jl from the equations in eom to simulate time-evolution within timespan. To manually input parameter values and initial conditions, use the keywords fixed_parameters and x0. To start the evolution from a steady-state solution, use steady_solution.\n\n\n\n\n\n","category":"function"},{"location":"manual/time_dependent/#HarmonicBalance.TimeEvolution.ParameterSweep","page":"Time evolution","title":"HarmonicBalance.TimeEvolution.ParameterSweep","text":"Represents a sweep of one or more parameters of a HarmonicEquation. During a sweep, the selected parameters vary linearly over some timespan and are constant elsewhere.\n\nSweeps of different variables can be combined using +.\n\nFields\n\nfunctions::Dict{Symbolics.Num, Function}\nMaps each swept parameter to a function.\n\nExamples\n\n# create a sweep of parameter a from 0 to 1 over time 0 -> 100\njulia> @variables a,b;\njulia> sweep = ParameterSweep(a => [0., 1.], (0, 100));\njulia> sweep[a](50)\n0.5\njulia> sweep[a](200)\n1.0\n\n# do the same, varying two parameters simultaneously\njulia> sweep = ParameterSweep([a => [0.,1.], b => [0., 1.]], (0,100))\n\n\n\n\n\n","category":"type"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"Using a time-dependent simulation can verify solution stability in cases where the Jacobian is too expensive to compute.","category":"page"},{"location":"manual/time_dependent/","page":"Time evolution","title":"Time evolution","text":"HarmonicBalance.TimeEvolution.is_stable","category":"page"},{"location":"manual/time_dependent/#HarmonicBalance.TimeEvolution.is_stable","page":"Time evolution","title":"HarmonicBalance.TimeEvolution.is_stable","text":"is_stable(soln::Dict{Symbolics.Num, ComplexF64}, eom::HarmonicEquation; timespan, tol, perturb_initial)\n\n\nNumerically investigate the stability of a solution soln of eom within timespan. The initial condition is displaced by perturb_initial.\n\nReturn true the solution evolves within tol of the initial value (interpreted as stable).\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#Extracting-harmonic-equations","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"","category":"section"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"Once a DifferentialEquation is defined and its harmonics specified, one can extract the harmonic equations using get_harmonic_equations, which itself is composed of the subroutines harmonic_ansatz, slow_flow, fourier_transform! and drop_powers. ","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"The harmonic equations use an additional time variable specified as slow_time in get_harmonic_equations. This is essentially a label distinguishing the time dependence of the harmonic variables (expected to be slow) from that of the oscillating terms (expeted to be fast). When the equations are Fourier-transformed to remove oscillating terms, slow_time is treated as a constant. Such an approach is exact when looking for steady states. ","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"get_harmonic_equations\nHarmonicBalance.harmonic_ansatz\nHarmonicBalance.slow_flow\nHarmonicBalance.fourier_transform\nHarmonicBalance.drop_powers","category":"page"},{"location":"manual/extracting_harmonics/#HarmonicBalance.get_harmonic_equations","page":"Extracting harmonic equations","title":"HarmonicBalance.get_harmonic_equations","text":"get_harmonic_equations(diff_eom::DifferentialEquation; fast_time=nothing, slow_time=nothing)\n\nApply the harmonic ansatz, followed by the slow-flow, Fourier transform and dropping  higher-order derivatives to obtain a set of ODEs (the harmonic equations) governing the harmonics of diff_eom.\n\nThe harmonics evolve in slow_time, the oscillating terms themselves in fast_time. If no input is used, a variable T is defined for slow_time and fast_time is taken as the independent variable of diff_eom.\n\nBy default, all products of order > 1 of slow_time-derivatives are dropped, which means the equations are linear in the time-derivatives.\n\nExample\n\njulia> @variables t, x(t), ω0, ω, F;\n\n# enter the simple harmonic oscillator\njulia> diff_eom = DifferentialEquation( d(x,t,2) + ω0^2 * x ~ F *cos(ω*t), x);\n\n# expand x in the harmonic ω\njulia> add_harmonic!(diff_eom, x, ω);\n\n# get equations for the harmonics evolving in the slow time T\njulia> harmonic_eom = get_harmonic_equations(diff_eom)\n\nA set of 2 harmonic equations\nVariables: u1(T), v1(T)\nParameters: ω0, ω, F\n\nHarmonic ansatz: \nx(t) = u1*cos(ωt) + v1*sin(ωt)\n\nHarmonic equations:\n\n(ω0^2)*u1(T) + (2//1)*ω*Differential(T)(v1(T)) - (ω^2)*u1(T) ~ F\n\n(ω0^2)*v1(T) - (ω^2)*v1(T) - (2//1)*ω*Differential(T)(u1(T)) ~ 0\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.harmonic_ansatz","page":"Extracting harmonic equations","title":"HarmonicBalance.harmonic_ansatz","text":"harmonic_ansatz(eom::DifferentialEquation, time::Num; coordinates=\"Cartesian\")\n\nExpand each variable of diff_eom using the harmonics assigned to it with time as the time variable. For each harmonic of each variable, an instance of HarmonicVariable (describing a pair of variables (u,v)) is automatically created and named. \n\ncoordinates allows for using different coordinate systems (e.g. 'polars') - CURRENTLY INACTIVE\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.slow_flow","page":"Extracting harmonic equations","title":"HarmonicBalance.slow_flow","text":"slow_flow(eom::HarmonicEquation; fast_time::Num, slow_time::Num, degree=2)\n\nRemoves all derivatives w.r.t fast_time (and their products) in eom of power degree. In the remaining derivatives, fast_time is replaced by slow_time.\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.fourier_transform","page":"Extracting harmonic equations","title":"HarmonicBalance.fourier_transform","text":"fourier_transform(eom::HarmonicEquation, time::Symbolics.Num) -> HarmonicEquation\n\n\nExtract the Fourier components of eom corresponding to the harmonics specified in eom.variables. For each harmonic of each variable, 2 equations are generated (cos and sin Fourier coefficients). time does not appear in the resulting equations anymore.\n\nUnderlying assumption: all time-dependences are harmonic.\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicBalance.drop_powers","page":"Extracting harmonic equations","title":"HarmonicBalance.drop_powers","text":"drop_powers(expr, vars, deg)\n\n\nRemove parts of expr where the combined power of vars is => deg.\n\nExample\n\njulia> @variables x,y;\njulia>drop_powers((x+y)^2, x, 2)\ny^2 + 2*x*y\njulia>drop_powers((x+y)^2, [x,y], 2)\n0\njulia>drop_powers((x+y)^2 + (x+y)^3, [x,y], 3)\nx^2 + y^2 + 2*x*y\n\n\n\n\n\n","category":"function"},{"location":"manual/extracting_harmonics/#HarmonicVariable-and-HarmonicEquation-types","page":"Extracting harmonic equations","title":"HarmonicVariable and HarmonicEquation types","text":"","category":"section"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"The equations governing the harmonics are stored using the two following structs. When going from the original to the harmonic equations, the harmonic ansatz x_i(t) = sum_j=1^M u_ij  (T)  cos(omega_ij t)+ v_ij(T) sin(omega_ij t) is used. Internally, each pair (u_ij v_ij) is stored as a HarmonicVariable. This includes the identification of omega_ij and x_i(t), which is needed to later reconstruct x_i(t).","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"HarmonicVariable","category":"page"},{"location":"manual/extracting_harmonics/#HarmonicBalance.HarmonicVariable","page":"Extracting harmonic equations","title":"HarmonicBalance.HarmonicVariable","text":"mutable struct HarmonicVariable\n\nHolds a pair of variables stored under symbols describing the harmonic ω of natural_variable. \n\nFields\n\nsymbols::Vector{Symbolics.Num}\nSymbols of the two variables in the HarmonicBalance namespace.\nnames::Dict{Symbolics.Num, String}\nHuman-readable labels of the two variables, used for plotting.\ntypes::Vector{String}\nTypes of the two variables ((u,v) for quadratures, (a,ϕ) for polars etc.)\nω::Symbolics.Num\nThe harmonic being described.\nnatural_variable::Symbolics.Num\nThe natural variable whose harmonic is being described.\n\n\n\n\n\n","category":"type"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"When the full set of equations of motion is expanded using the harmonic ansatz, the result is stored as a HarmonicEquation. For an initial equation of motion consisting of M variables, each expanded in N harmonics, the resulting HarmonicEquation holds 2NM equations of 2NM variables. Each symbol not corresponding to a variable is identified as a parameter. ","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"A HarmonicEquation can be either parsed into a steady-state Problem or solved using a dynamical ODE solver.","category":"page"},{"location":"manual/extracting_harmonics/","page":"Extracting harmonic equations","title":"Extracting harmonic equations","text":"HarmonicEquation","category":"page"},{"location":"manual/extracting_harmonics/#HarmonicBalance.HarmonicEquation","page":"Extracting harmonic equations","title":"HarmonicBalance.HarmonicEquation","text":"mutable struct HarmonicEquation\n\nHolds a set of algebraic equations governing the harmonics of a DifferentialEquation.\n\nFields\n\nequations::Vector{Symbolics.Equation}\nA set of equations governing the harmonics.\nvariables::Vector{HarmonicVariable}\nA set of variables describing the harmonics.\nparameters::Vector{Symbolics.Num}\nThe parameters of the equation set.\nnatural_equation::DifferentialEquation\nThe natural equation (before the harmonic ansatz was used).\n\n\n\n\n\n","category":"type"},{"location":"manual/saving/#Saving-and-loading","page":"Saving and loading","title":"Saving and loading","text":"","category":"section"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"All of the types native to HarmonicBalance.jl can be saved into a .jld2 file using save and loaded using load. Most of the saving/loading is performed using the package JLD2.jl, with the addition of reinstating the symbolic variables in the HarmonicBalance namespace (needed to parse expressions used in the plotting functions) and recompiling stored functions (needed to evaluate Jacobians). As a consequence, composite objects such as Result can be saved and loaded with no loss of information.","category":"page"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"HarmonicBalance.save\nHarmonicBalance.load","category":"page"},{"location":"manual/saving/#HarmonicBalance.save","page":"Saving and loading","title":"HarmonicBalance.save","text":"save(filename, object)\n\n\nSaves object into .jld2 file filename (the suffix is added automatically if not entered). The resulting file contains a dictionary with a single entry.\n\n\n\n\n\n","category":"function"},{"location":"manual/saving/#HarmonicBalance.load","page":"Saving and loading","title":"HarmonicBalance.load","text":"load(filename)\n\n\nLoads an object from filename. For objects containing symbolic expressions such as HarmonicEquation, the symbolic variables are reinstated in the HarmonicBalance namespace.\n\n\n\n\n\n","category":"function"},{"location":"manual/saving/","page":"Saving and loading","title":"Saving and loading","text":"","category":"page"},{"location":"examples/time_dependent/#Introduction:-time-dependent-simulations","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"","category":"section"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Most of HarmonicBalance.jl is focused on finding and analysing the steady states. Such states contain no information about transient behaviour, which is crucial to answer the following.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Given an initial condition, which steady state does the system evolve into?\nHow does the system behave if its parameters are varied in time?","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"It is straightforward to evolve the full equation of motion using an ODE solver. However, tracking oscillatory behaviour is computationally expensive.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"In the background, we showed that nonlinear driven systems may be reduced to harmonic equations","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"beginequation labeleqharmeq\nfracdmathbfu(T)dT  = barmathbfF (mathbfu)\nendequation","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"As long as the chosen harmonics constituting mathbfu(T) capture the system's behaviour, we may numerically evolve  Eq. \\eqref{eq:harmeq} instead of the full problem. Since the components of mathbfu(T) only vary very slowly (and are constant in a steady state), this is usually vastly more efficient than evolving the full problem. ","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Here we primarily demonstrate on the parametrically driven oscillator. The relevant notebooks may be found in the example repo.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"We start by defining our system.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"using HarmonicBalance\n@variables Ω, γ, λ, F, x, θ, η, α, ω, ψ, T, t, x(t)\n\nnatural_equation =  d(d(x,t),t) + γ*d(x,t) + Ω^2*(1-λ*cos(2*ω*t+ψ))*x + α*x^3 + η*d(x,t)*x^2\nforce =  F*cos(ω*t+θ)\ndEOM = HarmonicBalance.DifferentialEquation(natural_equation + force, x)\nHarmonicBalance.add_harmonic!(dEOM, x, ω); # single-frequency ansatz\n\n# construct the harmonic equations\nharmonic_eqs = HarmonicBalance.get_harmonic_equations(dEOM)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"A set of 2 harmonic equations\nVariables: u1(T), v1(T)\n...","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"The object harmonic_eqs encodes Eq. \\eqref{eq:harmeq}.   ","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"We now wish to parse this input into DifferentialEquations.jl and use its powerful ODE solvers. The desired object here is DifferentialEquations.ODEProblem, which is then fed into DifferentialEquations.solve.","category":"page"},{"location":"examples/time_dependent/#Evolving-from-an-initial-condition","page":"Introduction: time-dependent simulations","title":"Evolving from an initial condition","text":"","category":"section"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Given mathbfu(T_0), what is mathbfu(T) at future times?","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"For constant parameters, a HarmonicEquation object can be fed into the constructor of ODEProblem. The syntax is similar to DifferentialEquations.jl : ","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"import HarmonicBalance.TimeEvolution: ODEProblem, DifferentialEquations.solve\nx0 = [0.0; 0.] # initial condition\nfixed = (Ω => 1.0,γ => 1E-2, λ => 5E-2, F => 1E-3,  α => 1., η=>0.3, θ => 0, ψ => 0, ω=>1.) # parameter values\n\node_problem = ODEProblem(harmonic_eqs, fixed, x0 = x0, timespan = (0,1000))","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"ODEProblem with uType Vector{Float64} and tType Int64. In-place: true\ntimespan: (0, 1000)\nu0: 2-element Vector{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"DifferentialEquations.jl takes it from here - we only need to use solve.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"time_evo = solve(ode_problem, saveat=1.);\nplot(getindex.(time_evo.u, 1), getindex.(time_evo.u,2))","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Running the above code with x0 = [0., 0.] and x0 = [0.2, 0.2] gives the plots","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/time_dependent/ss_approach.png\" width=\"900\" alignment=\"center\" \\>","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"⠀","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Let us compare this to the steady state diagram.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"range = ω => LinRange(0.9, 1.1, 100)           # range of parameter values\nsolutions = get_steady_states(harmonic_eqs, range, fixed)\nplot_1D_solutions(solutions, x=\"ω\", y=\"sqrt(u1^2 + v1^2)*sign(u1)\");","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/time_dependent/parametron_response.png\" width=\"600\" alignment=\"center\" \\>","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"⠀","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Clearly when evolving from x0 = [0.,0.], the system ends up in the low-amplitude branch 2. With x0 = [0.2, 0.2], the system ends up in branch 3.","category":"page"},{"location":"examples/time_dependent/#Parameter-sweeps","page":"Introduction: time-dependent simulations","title":"Parameter sweeps","text":"","category":"section"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Experimentally, the primary means of exploring the steady state landscape is an adiabatic sweep one or more of the system parameters. This takes the system along a solution branch. If this branch disappears or becomes unstable, a jump occurs.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"The object ParameterSweep specifies a sweep, which is then used as an optional sweep keyword in the ODEProblem constructor.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"sweep = ParameterSweep(ω => (0.9,1.1), (0, 2E4))","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"The sweep linearly interpolates between omega = 09 at time 0 and omega  = 11 at time 2e4. For earlier/later times, omega is constant.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Let us now define a new ODEProblem which incorporates sweep and again use solve:","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"ode_problem = ODEProblem(harmonic_eqs, fixed, sweep=sweep, x0=[0.1;0.0], timespan=(0, 2E4))\ntime_evo = solve(prob, saveat=100)\nplot(time_evo.t, sqrt.(getindex.(time_evo.u,1).^2 .+ getindex.(time_evo,2).^2))","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/time_dependent/sweep_omega.png\" width=\"450\" alignment=\"center\" \\>","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"⠀ We see the system first evolves from the initial condition towards the low-amplitude steady state. The amplitude increases as the sweep proceeds, with a jump occurring around omega = 108 (i.e., time 18000).","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Successive weeps can be combined,","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"sweep1 = ParameterSweep(ω => [0.95, 1.0], (0, 2E4))\nsweep2 = ParameterSweep(λ => [0.05, 0.01], (2E4, 4E4))\nsweep = sweep1 + sweep2","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"multiple parameters can be swept simultaneously,","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"sweep = ParameterSweep([ω => [0.95;1.0], λ => [5E-2;1E-2]], (0, 2E4))","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"and custom sweep functions may be used.","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"ωfunc(t) = cos(t)\nsweep = ParameterSweep(ω => ωfunc)","category":"page"},{"location":"examples/time_dependent/","page":"Introduction: time-dependent simulations","title":"Introduction: time-dependent simulations","text":"Either of the above can be fed into ODEProblem and simulated. See here for more examples.","category":"page"},{"location":"examples/single_parametron_time_dep/#Time-dependent-simulations:-parametron","page":"Time-dependent simulations: parametron","title":"Time-dependent simulations: parametron","text":"","category":"section"},{"location":"examples/single_parametron_time_dep/","page":"Time-dependent simulations: parametron","title":"Time-dependent simulations: parametron","text":"The parametrically driven oscillator can be solved in time domain using the interface with DifferentialEquations.jl.  Here we skip detailed steps in the derivation of the harmonic, slow-flow differential equations, which can be found in  Parametrically driven Duffing resonator. In short:","category":"page"},{"location":"examples/single_parametron_time_dep/","page":"Time-dependent simulations: parametron","title":"Time-dependent simulations: parametron","text":"using HarmonicBalance.jl\n@variables Ω,γ,λ,F, x,θ,η,α, ω, ψ, x(t), t\n\nnatural_equation =  d(d(x,t),t) + γ*d(x,t) + Ω^2*(1-λ*cos(2*ω*t+ψ))*x + α * x^3 + η *d(x,t) * x^2\nforces =  F*cos(ω*t+θ)\ndEOM = HarmonicBalance.DifferentialEquation(natural_equation + forces, x)\n\nHarmonicBalance.add_harmonic!(dEOM, x, ω);\n\n@time averagedEOM = HarmonicBalance.get_harmonic_equations(dEOM)","category":"page"},{"location":"examples/single_parametron_time_dep/","page":"Time-dependent simulations: parametron","title":"Time-dependent simulations: parametron","text":"We choose to visualize the dynamics of the harmonic variables uv in phase space. For it, we setup the initial conditions x(t=0)=x_0 for the simulation","category":"page"},{"location":"examples/single_parametron_time_dep/","page":"Time-dependent simulations: parametron","title":"Time-dependent simulations: parametron","text":"x0 = [0.0037178842249515134; 0.]\ntimes = (0.,1000.)\ndt = 1. # time-resolution of the result (NOT the integration timestep)\nfixed_parameters = ParameterList(Ω => 1.0,γ => 1E-2, λ => 5E-2, F => 1E-3,  α => 1., η=>0.3, θ => 0, ψ => 0, ω=>1.)","category":"page"},{"location":"examples/single_parametron_time_dep/","page":"Time-dependent simulations: parametron","title":"Time-dependent simulations: parametron","text":"Finally, we solve the harmonic equations and represent the solutions  by","category":"page"},{"location":"examples/single_parametron_time_dep/","page":"Time-dependent simulations: parametron","title":"Time-dependent simulations: parametron","text":"time_dep = HarmonicBalance.TimeEvolution.ODEProblem(averagedEOM, fixed_parameters, sweep=HarmonicBalance.TimeEvolution.ParameterSweep(), x0 = x0, timespan = times);\ntime_soln = HarmonicBalance.TimeEvolution.solve(time_dep, saveat=dt);\nHarmonicBalance.plot(getindex.(time_soln.u, 1), getindex.(time_soln.u,2))\nHarmonicBalance.xlabel(\"u\",fontsize=20)\nHarmonicBalance.ylabel(\"v\",fontsize=20)","category":"page"},{"location":"examples/single_parametron_time_dep/","page":"Time-dependent simulations: parametron","title":"Time-dependent simulations: parametron","text":"The result is depicted below. At large times, the dynamics is equivalent to a particle spiralling down towards a steadystate, which is not set at (uv)=(00), but at a finite amplitude.","category":"page"},{"location":"examples/single_parametron_time_dep/","page":"Time-dependent simulations: parametron","title":"Time-dependent simulations: parametron","text":"(Image: fig1)","category":"page"},{"location":"manual/solving_harmonics/#Solving-harmonic-equations","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"","category":"section"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Once a differential equation of motion has been defined in DifferentialEquation and converted to a HarmonicEquation, we may use the homotopy continuation method (as implemented in HomotopyContinuation.jl) to find steady states. This means that, having called get_harmonic_equations, we need to set all time-derivatives to zero and parse the resulting algebraic equations into a Problem.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Problem holds the steady-state equations, and (optionally) the symbolic Jacobian which is needed for stability / linear response calculations. ","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Once defined, a Problem can be solved for a set of input parameters using get_steady_states to obtain Result.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Problem\nget_steady_states\nResult","category":"page"},{"location":"manual/solving_harmonics/#HarmonicBalance.Problem","page":"Solving harmonic equations","title":"HarmonicBalance.Problem","text":"mutable struct Problem\n\nHolds a set of algebraic equations describing the steady state of a system.\n\nFields\n\nvariables::Vector{Symbolics.Num}\nThe harmonic variables to be solved for.\nparameters::Vector{Symbolics.Num}\nAll symbols which are not the harmonic variables.\nsystem::HomotopyContinuation.ModelKit.System\nThe input object for HomotopyContinuation.jl solver methods.\njacobian::Any\nThe Jacobian matrix (possibly symbolic).     If false, the Jacobian is ignored (may be calculated implicitly after solving).\neom::HarmonicEquation\nThe HarmonicEquation object used to generate this Problem.\n\nConstructors\n\nProblem(eom::HarmonicEquation; Jacobian=true) # find and store the symbolic Jacobian\nProblem(eom::HarmonicEquation; Jacobian=false) # ignore the Jacobian for now\nProblem(eom::HarmonicEquation; Jacobian::Matrix) # use the given matrix as the Jacobian\n\n\n\n\n\n","category":"type"},{"location":"manual/solving_harmonics/#HarmonicBalance.get_steady_states","page":"Solving harmonic equations","title":"HarmonicBalance.get_steady_states","text":"get_steady_states(prob::Problem, \n                    swept_parameters::ParameterRange,\n                    fixed_parameters::ParameterList;\n                    random_warmup=false,\n                        threading=false,\n                        sorting=\"hilbert\")\n\nSolves prob over the ranges specified by swept_parameters, keeping fixed_parameters constant. swept_parameters accepts pairs mapping symbolic variables to arrays or LinRange. fixed_parameters accepts pairs mapping symbolic variables to numbers. \n\nKeyword arguments\n\nrandom_warmup: If true, a problem similar to prob but with random complex parameters is first solved to find all non-singular paths. The subsequent tracking to find results for all sweptparameters is then much faster than the initial solving. If `randomwarmup=false`, each parameter point is solved separately by tracking the maximum number of paths (employs a total degree homotopy).\n\nThis takes far longer but can be more reliable.\n\nthreading: If true, multithreaded support is activated. The number of available threads is set by the environment variable JULIA_NUM_THREADS. \nsorting: the method used by sort_solutions to get continuous solutions branches.  The current options are \"hilbert\" (1D sorting along a Hilbert curve), \"nearest\" (nearest-neighbor sorting) and \"none\".\n\nExample: solving a simple harmonic oscillator m ddotx + γ dotx + ω_0^2 x = F cos(ωt) to obtain the response as a function of ω\n\n# having obtained a Problem object, let's find steady states\njulia> range = ParameterRange(ω => LinRange(0.8,1.2,100) ) # 100 parameter sets to solve\njulia> fixed = ParameterList(m => 1, γ => 0.01, F => 0.5, ω_0 => 1)\njulia> get_steady_states(problem, range, fixed)\n\nA steady state result for 100 parameter points\n\n    Solution branches:   1\n       of which real:    1\n       of which stable:  1\n    \n    Classes: stable, physical, Hopf, binary_labels\n    \n\nIt is also possible to create multi-dimensional solutions plots. \n\n# The swept parameters take precedence over fixed -> use the same fixed\njulia> range = ParameterRange(ω => LinRange(0.8,1.2,100), F => LinRange(0.1,1.0,10) ) # 100x10 parameter sets\n\n# The swept parameters take precedence over fixed -> the F in fixed is now ignored\njulia> get_steady_states(problem, range, fixed)\n\nA steady state result for 1000 parameter points\n\n    Solution branches:   1\n       of which real:    1\n       of which stable:  1\n    \n    Classes: stable, physical, Hopf, binary_labels\n\n\n\n\n\n","category":"function"},{"location":"manual/solving_harmonics/#HarmonicBalance.Result","page":"Solving harmonic equations","title":"HarmonicBalance.Result","text":"mutable struct Result\n\nStores the steady states of a HarmonicEquation.\n\nFields\n\nsolutions::Array{Vector{Vector{ComplexF64}}}\nThe variable values of steady-state solutions.\nswept_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Vector{Float64}}\nValues of all parameters for all solutions.\nfixed_parameters::OrderedCollections.OrderedDict{Symbolics.Num, Float64}\nThe parameters fixed throughout the solutions.\nproblem::Problem\nThe Problem used to generate this.\nclasses::Dict{String, Array}\nMaps strings such as \"stable\", \"physical\" etc to arrays of values, classifying the solutions (see method classify_solutions!).\njacobian::Any\nThe Jacobian with fixed_parameters already substituted. Accepts a dictionary specifying the solution.     If problem.jacobian is a symbolic matrix, this holds a compiled function.     If problem.jacobian was false, this holds a function that rearranges the equations to find J     only after numerical values are inserted (preferable in cases where the symbolic J would be very large).\n\n\n\n\n\n","category":"type"},{"location":"manual/solving_harmonics/#Classifying-solutions","page":"Solving harmonic equations","title":"Classifying solutions","text":"","category":"section"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"The solutions in Result are accompanied by similarly-sized boolean arrays stored in the dictionary Result.classes. The classes can be used by the plotting functions to show/hide/label certain solutions.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"By default, classes \"physical\", \"stable\" and \"binary_labels\" are created. User-defined classification is possible with classify_solutions!.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"HarmonicBalance.classify_solutions!","category":"page"},{"location":"manual/solving_harmonics/#HarmonicBalance.classify_solutions!","page":"Solving harmonic equations","title":"HarmonicBalance.classify_solutions!","text":"classify_solutions!(res::Result, condition::String, name::String; physical) -> Any\n\n\nCreates a solution class in res using the inequality condition (parsed into Symbolics.jl input).\n\nThe new class is labelled with name and stored under res.classes[name].\n\nBy default, only physical (=real) solutions are classified, false is returned for the rest.\n\nExample\n\n# solve a previously-defined problem\nres = get_steady_states(problem, swept_parameters, fixed_parameters)\n\n# classify, store in result.classes[\"large_amplitude\"]\nclassify_solutions!(res, \"sqrt(u1^2 + v1^2) > 1.0\" , \"large_amplitude\")\n\n\n\n\n\n","category":"function"},{"location":"manual/solving_harmonics/#Sorting-solutions","page":"Solving harmonic equations","title":"Sorting solutions","text":"","category":"section"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Solving a steady-state problem over a range of parameters returns a solution set for each parameter. For a continuous change of parameters, each solution in a set usually also changes continuously; it is said to form a ''solution branch''. For an example, see the three colour-coded branches for the Duffing oscillator in Example 1.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"For stable states, the branches describe a system's behaviour under adiabatic parameter changes. ","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Therefore, after solving for a parameter range, we want to order each solution set such that the solutions' order reflects the branches.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"The function sort_solutions goes over the the raw output of get_steady_states and sorts each entry such that neighboring solution sets minimize Euclidean distance.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"Currently, sort_solutions is compatible with 1D and 2D arrays of solution sets.","category":"page"},{"location":"manual/solving_harmonics/","page":"Solving harmonic equations","title":"Solving harmonic equations","text":"HarmonicBalance.sort_solutions","category":"page"},{"location":"manual/solving_harmonics/#HarmonicBalance.sort_solutions","page":"Solving harmonic equations","title":"HarmonicBalance.sort_solutions","text":"sort_solutions(solutions::Array; sorting) -> Any\n\n\nSorts solutions into branches according to the method sorting.\n\nsolutions is an n-dimensional array of Vector{Vector}. Each element describes a set of solutions for a given parameter set. The output is a similar array, with each solution set rearranged such that neighboring solution sets have the smallest Euclidean distance.\n\n\n\n\n\n","category":"function"},{"location":"examples/single_parametron_2D/#Phase-diagrams-and-solutions-in-2D:-parametron","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"","category":"section"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"The parametrically driven oscillator boasts a stability diagram called \"Arnold's tongues\" delineating zones where the oscillator is stable from those where it is exponentially unstable (if the nonlinearity was absence).  We can retrieve this diagram by calculating the steady states as a function of external detuning delta=omega_L-omega_0 and the parametric drive strength lambda.  We adress this problem by first obtaining the harmonic equations, i.e. averaging the parametrically driven Duffing oscillator equations around a single frequency omega (see Parametrically driven Duffing resonator example).","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"using HarmonicBalance,Latexify,PyPlot\n\n@variables ω₁, ω, γ,λ, t, T, α₁, x(t)\n\n#sympy object for the equation of motion\nnatural_equation = d(d(x, t),t) + ω₁^2*(1-λ*cos(2*ω*t)) * x + γ*d(x,t)  + α₁*x^3\n\ndEOM = DifferentialEquation(natural_equation, x)\n\nHarmonicBalance.add_harmonic!(dEOM, x, ω) # x will rotate at ω\n\naveragedEOM = get_harmonic_equations(dEOM, slow_time=T, fast_time=t)","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"To perform a 2D sweep over driving frequency omega and parametric drive strength lambda, we simply execute the block","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"fixed_parameters = ([(ω₁, 1.),(γ, 0.05),(α₁, -0.99)])\n\nswept_parameters = (ω => LinRange(0.8,1.2,100), λ => LinRange(0.001,0.6,120))\n\n#best results for random_warmup=false, so beginning from a total degree homotopy and pass parameters one by one to the solver\nsol_2D = HarmonicBalance.get_steady_states(averagedEOM, swept_parameters, fixed_parameters; random_warmup=false, threading=false,sorting=\"nearest\")","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"Now, we count the number of solutions for each point and represent the corresponding phase diagram in parameter space. For it, we employ plot_2D_phase_diagram phase diagram function with stable=false","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"HarmonicBalance.plot_2D_phase_diagram(sol_2D, stable=false,observable=\"nsols\",filename=\"plot_2D_phase_diagram\")","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"and generates the diagram","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"(Image: fig1)","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"Here we also we gave a value to the filename argument, to output plot_data directly as as .jld2file. The number of stable solutions can be represented by setting stable=true above. We observe boundaries (bifurcations) where the number of solutions changes. ","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"In addition to phase diagrams, we can directly retrieve plots for the solutions by simply calling ","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"    save_dict = HarmonicBalance.plot_2D_solutions(sol_2D)","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"which returns an array of panels with a solution in a given panel in columns corresponding to each harmonic variable uv","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"(Image: fig2)","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"Note that solutions are ordered in parameter space according to their closest neighbors. Plots can be limited to a given class (e.g stable solutions only) through the argument plot_only, for instance  ","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"    save_dict = HarmonicBalance.plot_2D_solutions(sol_2D,plot_only=[\"stable\"])","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"Solution maps can also implemented and can be passed through the argument z. For instance, the radius X=sqrtu^1+v^2 can be represented by passing z=\"sqrt(u1^2+v1^2) (note the automatic naming of the harmonic variables assigns a number even if the problem is single-dimensional). These, individual, solution maps can be combined with multi-solution maps, such as X among different solutions, by adding functions to plot_only. For instance","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"    save_dict = HarmonicBalance.plot_2D_solutions(sol_2D,plot_only=[\"stable\",Base.maximum],z=\"sqrt(u1^2+v1^2)\")","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"produces a plot depicting  X for all stable solutions:","category":"page"},{"location":"examples/single_parametron_2D/","page":"Phase diagrams and solutions in 2D: parametron","title":"Phase diagrams and solutions in 2D: parametron","text":"(Image: fig3)","category":"page"},{"location":"examples/linear_response/#linresp_ex","page":"Introduction: linear response","title":"Introduction: linear response","text":"","category":"section"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"In HarmonicBalance.jl, the stability and linear response are treated using the LinearResponse module. ","category":"page"},{"location":"examples/linear_response/#Example:-driven-Duffing-resonator","page":"Introduction: linear response","title":"Example: driven Duffing resonator","text":"","category":"section"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"Here we calculate the white noise response of a simple nonlinear system. A set of reference results may be found in Huber et al. in Phys. Rev. X 10, 021066 (2020). The code is also available as a Jupyter notebook. ","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"We start by defining the Duffing oscillator","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"using HarmonicBalance\n@variables α, ωF, ω0, F, t, q(t), γ, Γ; # declare constant variables and a function q(t)\n\n# define ODE\ndiff_eq = DifferentialEquation(d(q,t,2) + 2*Γ*d(q,t) + ω0^2*q + γ*q^3 ~ F*cos(ωF*t), q)\n\n# specify the ansatz q = u(T) cos(ωF*t) + v(T) sin(ωF*t)\nadd_harmonic!(diff_eq, q, ωF) \n\n# implement ansatz to get harmonic equations\nharmonic_eq = get_harmonic_equations(diff_eq)","category":"page"},{"location":"examples/linear_response/#Linear-regime","page":"Introduction: linear response","title":"Linear regime","text":"","category":"section"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"When driven weakly, the Duffing resonator behaves quasi-linearly, i.e, its response to noise is independent of the applied drive. We see that for weak driving, F = 10^-6, the amplitude is a Lorentzian. ","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"fixed = (α => 1, ω0 => 1.0, γ => 1E-2, F => 1E-6)   # fixed parameters\nswept = ω => LinRange(0.9, 1.1, 100)           # range of parameter values\nsolutions = get_steady_states(harmonic_eq, swept, fixed)\n\nplot_1D_solutions(solutions, x=\"ω\", y=\"sqrt(u1^2 + v1^2)\")","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; margin: 0 auto; padding-bottom: 20px;\" src=\"../../assets/linear_response/Duffing_quasilin_amp.png\" width=\"450\" alignment=\"left\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"⠀ The linear response is obtained with plot_jacobian_spectrum, note that the branch number and the variable (here x) must be specified. The response has a peak at omega_0, irrespective of omega :","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"HarmonicBalance.LinearResponse.plot_jacobian_spectrum(solutions, x, \n    Ω_range=LinRange(0.9, 1.1, 300), branch=1, logscale=true)","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/linear_response/Duffing_quasilin_noise.png\" width=\"450\" alignment=\"left\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"⠀ Note the slight \"bending\" of the noise peak with omega - this is given by the failure of the Jacobian to capture response far-detuned from the drive frequency. More on this point will follow in a future example.","category":"page"},{"location":"examples/linear_response/#Nonlinear-regime","page":"Introduction: linear response","title":"Nonlinear regime","text":"","category":"section"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"For strong driving, matters get more complicated. Let us now use a drive F = 10^-2 :","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"fixed = (α => 1, ω0 => 1.0, γ => 1E-2, F => 1E-2)   # fixed parameters\nswept = ω => LinRange(0.9, 1.1, 100)           # range of parameter values\nsolutions = get_steady_states(harmonic_eq, swept, fixed)\n\nplot_1D_solutions(solutions, x=\"ω\", y=\"sqrt(u1^2 + v1^2)\");","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/linear_response/Duffing_nonlin_amp.png\" width=\"450\" alignment=\"left\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"⠀","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"The amplitude is the well-known Duffing curve. Let's see the linear response of the two stable branches, 1 and 2.","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"LinearResponse.plot_jacobian_spectrum(solutions, x, \n    Ω_range=LinRange(0.9,1.1,300), branch=1, logscale=true);\n\nLinearResponse.plot_jacobian_spectrum(solutions, x, \n    Ω_range=LinRange(0.9,1.1,300), branch=2, logscale=true);","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; padding-bottom: 20px;\" src=\"../../assets/linear_response/Duffing_nonlin_noise12.png\" width=\"900\" alignment=\"center\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"⠀ In branch 1 the linear response to white noise shows more than one peak. This is a distinctly nonlinear phenomenon, manifesting primarily at large amplitudes. Branch 2 is again quasi-linear, which stems from its low amplitude.","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"Following Huber et al., we may also fix omega = omega_0 and plot the linear response as a function of F. The response turns out to be single-valued over a large range of driving strengths. Using a log scale for the x-axis:","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"fixed = (α => 1., ω0 => 1.0, γ => 1E-2, ω => 1)   # fixed parameters\nswept = F => 10 .^ LinRange(-6, -1, 200)           # range of parameter values\nsolutions = get_steady_states(harmonic_eq, swept, fixed)\n\nplot_1D_solutions(solutions, x=\"F\", y=\"sqrt(u1^2 + v1^2)\");\nHarmonicBalance.xscale(\"log\") # use log scale on x\n\nLinearResponse.plot_jacobian_spectrum(solutions, x, \n    Ω_range=LinRange(0.9,1.1,300), branch=1, logscale=true);\nHarmonicBalance.xscale(\"log\")","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"<img style=\"display: block; padding-bottom: 20px;\" src=\"../../assets/linear_response/Duffing_nonlin_forcex.png\" width=\"800\" alignment=\"center\" \\>","category":"page"},{"location":"examples/linear_response/","page":"Introduction: linear response","title":"Introduction: linear response","text":"⠀ We see that for low F, quasi-linear behaviour with a single Lorentzian response occurs, while for larger F, two peaks form in the noise response. The two peaks are strongly unequal in magnitude, which is an example of internal squeezing.","category":"page"},{"location":"background/stability_response/#linresp_background","page":"Stability and linear response","title":"Stability and linear response","text":"","category":"section"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"The core of the harmonic balance method is expressing the system's behaviour in terms of Fourier components or harmonics. For an N-coordinate system, we choose a set of M_i harmonics to describe each coordinate x_i : ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"x_i(t) = sum_j=1^M_i u_ij  (T)  cos(omega_ij t)+ v_ij (T) sin(omega_ij t) ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"This means the system is now described using a discrete set of variables u_ij and v_ij. Constructing a vector mathbfu(T) = (u_11(T) v_11(T) ldots u_NM_N(T) v_N M_N(T)), we may obtain the harmonic equations (see an example of this procedure)","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation labeleqharmeq\nfracdmathbfu(T)dT  = barmathbfF (mathbfu)\nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"where barmathbfF(mathbfu) is a nonlinear function. A steady state mathbfu_0 is defined by barmathbfF(mathbfu_0) = 0.","category":"page"},{"location":"background/stability_response/#Stability","page":"Stability and linear response","title":"Stability","text":"","category":"section"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Let us assume that we found a steady state mathbfu_0. When the system is in this state, it responds to small perturbations either by returning to mathbfu_0 over some characteristic timescale (stable state) or by evolving away from mathbfu_0 (unstable state). To analyze the stability of mathbfu_0, we linearize Eq. \\eqref{eq:harmeq} around mathbfu_0 for a small perturbation delta mathbfu = mathbfu - mathbfu_0 to obtain","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation labeleqJaceq\nfracddT leftdelta mathbfu(T)right =  J(mathbfu_0) delta mathbfu(T) \nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"where J(mathbfu_0)=nabla_mathbfu  barmathbfF_mathbfu=mathbfu_0 is the Jacobian matrix of the system evaluated at mathbfu=mathbfu_0.","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Eq. \\eqref{eq:Jaceq} is exactly solvable for delta mathbfu(T) given an initial condition delta mathbfu(T_0). The solution can be expanded in terms of the complex eigenvalues lambda_r and eigenvectors mathbfv_r of J(mathbfu_0), namely","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"beginequation labeleqfluct_evo\n    delta mathbfu(T) = sum_r(mathbfv_rcdot deltamathbfu(T_0))hspace1mmmathbfv_r e^lambda_r T\nendequation","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"The dynamical behaviour near the steady states is thus governed by e^ lambda_r T: if mathrmRe(lambda_r)0 for all lambda_r, the state mathbfu_0 is stable. Conversely, if mathrmRe(lambda_r)0 for at least one lambda_r, the state is unstable - perturbations such as noise or a small applied drive will force the system away from mathbfu_0. ","category":"page"},{"location":"background/stability_response/#Linear-response-(WIP)","page":"Stability and linear response","title":"Linear response (WIP)","text":"","category":"section"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"The response of a stable steady state to an additional oscillatory force, caused by weak probes or noise, is often of interest. It can be calculated by solving for the perturbation delta mathbfu in the presence of an additional drive term.","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"The linear response of the system in the state mathbfu_0 is thus encoded in the complex eigenvalues and eigenvectors of J(mathbfu_0). ","category":"page"},{"location":"background/stability_response/","page":"Stability and linear response","title":"Stability and linear response","text":"Check out this example of the linear response module of HarmonicBalance.jl","category":"page"},{"location":"examples/single_Duffing/#Duffing","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"","category":"section"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Here we show the workflow of HarmonicBalance.jl on a simple example - the driven Duffing oscillator.","category":"page"},{"location":"examples/single_Duffing/#The-equations","page":"Introduction: the Duffing oscillator","title":"The equations","text":"","category":"section"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The equation of motion for the displacement x(t) reads","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"beginequation labeleqduffing\nunderbraceddotx(t) + gamma dotx(t) + omega_0^2 x(t)_textdamped harmonic oscillator + underbracealpha x(t)^3_textDuffing coefficient = underbraceF cos(omega t)_textperiodic drive\nendequation","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"For alpha=0, the system becomes linear and responds precisely at the drive frequency, so that x(t) = X cos(omega t + phi), where X and phi can be found analytically. For alpha neq 0 this is no longer possible. ","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"We can obtain some intuition by treating alpha perturbatively, i.e., by solving","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"ddotx(t) + gamma dotx(t) + omega_0^2 x(t) + epsilon alpha x(t)^3 = F cos(omega t)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"for small epsilon. To zeroth order, the response of the system is x_0(t) = X_0 cos(omega t + phi_0). Expanding x(t) = x_0(t) + epsilon x_1(t), we find that the perturbation x_1(t) satisfies to first order","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"ddotx_1(t) + gamma dotx_1(t) left omega_0^2 + frac3 alpha X_0^24 right x_1(t) = - fracalpha X_0^34 cos(3 omega t + 3 phi_0) ","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"which gives a response of the form x_1(t) = X_1 cos(3 omega t + phi_1). Clearly, the oscillator now responds not only at frequency omega, but also at 3 omega! This effect is known as high harmonic generation or more generally frequency conversion. By continuing the procedure to higher orders, we eventually obtain an infinity of harmonics present in the response. In general, there is no analytical solution to such problems.","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Fortunately, some harmonics are more important than others. By truncating the infinite-dimensional Fourier space to a set of judiciously chosen harmonics, we may obtain a soluble system. For the Duffing resonator, we can well try to only consider the drive frequency omega. To implement this, we use the harmonic ansatz","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"x(t) = U cos(omega t) + V sin(omega t) ","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"which constraints the spectrum of x(t) to a single harmonic. Fixing the quadratures U and V to be constant then reduces the differential equation \\eqref{eq:duffing} to two coupled cubic polynomial equations (for more details on this step, see the appendices in https://arxiv.org/abs/2202.00571). Finding the roots of coupled polynomials is in general very hard. We here apply the method of homotopy continuation, as implemented in HomotopyContinuation.jl which is guaranteed to find the complete set of roots.","category":"page"},{"location":"examples/single_Duffing/#The-code","page":"Introduction: the Duffing oscillator","title":"The code","text":"","category":"section"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"First we need to declare the symbolic variables (the excellent Symbolics.jl is used here).","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"using HarmonicBalance\n@variables α, ω, ω0, F, t, γ, x(t) # declare constant variables and a function x(t)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Next, we have to input Eq.\\eqref{eq:duffing}. This will be stored as a DifferentialEquation. The input needs to specify that only x is a mathematical variable, the other symbols are parameters:","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"diff_eq = DifferentialEquation(d(x,t,2) + ω0^2*x + α*x^3 + γ*d(x,t) ~ F*cos(ω*t), x)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The harmonic ansatz needs to specified now – we expand x in a single frequency omega.","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"add_harmonic!(diff_eq, x, ω) # specify the ansatz x = u(T) cos(ωt) + v(T) sin(ωt)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The object diff_eq now contains all the necessary information","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"System of 1 differential equations\nVariables:       x(t)\nHarmonic ansatz: x(t) => ω;   \n\nα*(x(t)^3) + (ω0^2)*x(t) + γ*Differential(t)(x(t)) + Differential(t)(Differential(t)(x(t))) ~ F*cos(t*ω)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"We are ready to start plugging in numbers and solving! First we convert the differential equation to the algebraic harmonic equations (coupled polynomials in U and V). ","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"harmonic_eq = get_harmonic_equations(diff_eq)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The resulting object shows:","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"A set of 2 harmonic equations\nVariables: u1(T), v1(T)\nParameters: α, ω, γ, ω0, F\n\nHarmonic ansatz: \nx(t) = u1*cos(ωt) + v1*sin(ωt)\n\nHarmonic equations:\n\nγ*Differential(T)(u1(T)) + (ω0^2)*u1(T) + (3//4)*α*(u1(T)^3) + γ*ω*v1(T) + (2//1)*ω*Differential(T)(v1(T)) + (3//4)*α*(v1(T)^2)*u1(T) - (ω^2)*u1(T) ~ F\n\n(ω0^2)*v1(T) + γ*Differential(T)(v1(T)) + (3//4)*α*(v1(T)^3) + (3//4)*α*(u1(T)^2)*v1(T) - (ω^2)*v1(T) - (2//1)*ω*Differential(T)(u1(T)) - γ*ω*u1(T) ~ 0","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The variables u1 and v1 were declared automatically to construct the harmonic ansatz. The slow time variable T describes variation of the quadratures on timescales much slower than ω. For a steady state, all derivatives w.r.t T vanish, leaving only algebraic equations to be solved. ","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Let us now find steady states by solving harmonic_eq for numerical parameters. Homotopy continuation is especially suited to solving over a range of parameter values. Here we will solve over a range of driving frequencies ω – these are stored as {Sym, Vector{Float64}} or {Sym, LinRange}:","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"varied = ω => LinRange(0.9, 1.2, 100) # range of parameter values","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The other parameters we be fixed – these are declared as {Sym, Float64} pairs:","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"fixed = (α => 1., ω0 => 1.0, F => 0.01, γ=>0.01) # fixed parameters","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Now everything is ready to crank the handle. get_steady_states solves our harmonic_eq using the varied and fixed parameters:","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"solutions = get_steady_states(harmonic_eq, varied, fixed)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The results are shown:","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"A steady state result for 100 parameter points\n\nSolution branches:   3\n   of which real:    3\n   of which stable:  2\n\nClasses: stable, physical, Hopf, binary_labels","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The algorithm has found 3 solution branches in total (out of the hypothetically admissible 3^2 = 9). All of these are real – and thefore physically observable – for at least some values of omega. Only 2 branches are stable under infinitesimal perturbations.","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The \"Classes\" are boolean labels classifying each solution point, which may be used to select results for plotting. # hide","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"We now want to visualize the results. Here we plot the solution amplitude, sqrtU^2 + V^2 against the drive frequency omega: ","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"plot_1D_solutions(solutions, x=\"ω\", y=\"sqrt(u1^2 + v1^2)\")","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"<img style=\"display: block; margin: 0 auto;\" src=\"../../assets/duffing_single.png\" width=\"450\" alignment=\"center\" \\>","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"⠀","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"This is the expected response curve for the Duffing equation.","category":"page"},{"location":"examples/single_Duffing/#Advanced:-using-multiple-harmonics","page":"Introduction: the Duffing oscillator","title":"Advanced: using multiple harmonics","text":"","category":"section"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"In the above example, we truncated the Fourier space to a single harmonic omega – the oscillator was assumed to only oscillate at the drive frequency. We however also argued that frequency conversion takes place, to first order from omega to 3 omega. We can reflect this process by using a larger harmonic ansatz:","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"beginequation\nx(t) = U_1 cos(omega t) + V_1 sin(omega t) + U_2 cos(3omega t) + V_2 sin(3omega t) \nendequation","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Note that this is not a perturbative treatment! The harmonics omega and 3 omega are on the same footing here. This is implemented as","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"add_harmonic!(diff_eq, x, [ω, 3ω]) # specify the two-harmonics ansatz\nharmonic_eq = get_harmonic_equations(diff_eq)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"A set of 4 harmonic equations\nVariables: u1(T), v1(T), u2(T), v2(T)\nParameters: ω, ω0, α, γ, F\n\nHarmonic ansatz: \nx(t) = u1*cos(ωt) + v1*sin(ωt) + u2*cos(3ωt) + v2*sin(3ωt)\n\nHarmonic equations:\n\n(ω0^2)*u1(T) + γ*Differential(T)(u1(T)) + (3//4)*α*(u1(T)^3) + γ*ω*v1(T) + (2//1)*ω*Differential(T)(v1(T)) + (3//2)*α*(u2(T)^2)*u1(T) + (3//4)*α*(u1(T)^2)*u2(T) + (3//4)*α*(v1(T)^2)*u1(T) + (3//2)*α*(v2(T)^2)*u1(T) + (3//2)*α*u1(T)*v1(T)*v2(T) - (ω^2)*u1(T) - (3//4)*α*(v1(T)^2)*u2(T) ~ F\n\nγ*Differential(T)(v1(T)) + (ω0^2)*v1(T) + (3//4)*α*(v1(T)^3) + (3//4)*α*(u1(T)^2)*v1(T) + (3//2)*α*(u2(T)^2)*v1(T) + (3//2)*α*(v2(T)^2)*v1(T) + (3//4)*α*(u1(T)^2)*v2(T) - (ω^2)*v1(T) - (2//1)*ω*Differential(T)(u1(T)) - γ*ω*u1(T) - (3//4)*α*(v1(T)^2)*v2(T) - (3//2)*α*u1(T)*u2(T)*v1(T) ~ 0\n\n(ω0^2)*u2(T) + γ*Differential(T)(u2(T)) + (1//4)*α*(u1(T)^3) + (3//4)*α*(u2(T)^3) + (6//1)*ω*Differential(T)(v2(T)) + (3//2)*α*(u1(T)^2)*u2(T) + (3//4)*α*(v2(T)^2)*u2(T) + (3//2)*α*(v1(T)^2)*u2(T) + (3//1)*γ*ω*v2(T) - (9//1)*(ω^2)*u2(T) - (3//4)*α*(v1(T)^2)*u1(T) ~ 0\n\nγ*Differential(T)(v2(T)) + (ω0^2)*v2(T) + (3//4)*α*(v2(T)^3) + (3//4)*α*(u1(T)^2)*v1(T) + (3//4)*α*(u2(T)^2)*v2(T) + (3//2)*α*(u1(T)^2)*v2(T) + (3//2)*α*(v1(T)^2)*v2(T) - (1//4)*α*(v1(T)^3) - (9//1)*(ω^2)*v2(T) - (6//1)*ω*Differential(T)(u2(T)) - (3//1)*γ*ω*u2(T) ~ 0\n","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The variables u1,v1 now encode ω and u2, v2 encode 3ω. We see this system is much harder to solve as we now have 4 harmonic variables, resulting in 4 coupled cubic equations. A maximum of 3^4 = 81 solutions may appear! ","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"For the above parameters (where a perturbative treatment would have been reasonable), the principal response at omega looks rather similar, with a much smaller upconverted component appearing at 3 omega: (Image: fig2)","category":"page"},{"location":"examples/single_Duffing/#Non-perturbative-results-(strong-interactions)","page":"Introduction: the Duffing oscillator","title":"Non-perturbative results (strong interactions)","text":"","category":"section"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The non-perturbative nature of Eq.(3) allows us to capture some behaviour which is not a mere extension of the usual single-harmonic Duffing response. Suppose we drive a strongly nonlinear resonator at frequency omega cong omega_0  3. Such a drive is far out of resonance, however, the upconverted harmonic 3 omega = omega_0 is not and may play an important role! Let us try this out:","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"fixed = (α => 10., ω0 => 3, F => 5, γ=>0.01)   # fixed parameters\nswept = ω => LinRange(0.9, 1.4, 100)           # range of parameter values\nsolutions = get_steady_states(harmonic_eq, swept, fixed)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"A steady state result for 100 parameter points\n\nSolution branches:   9\n   of which real:    3\n   of which stable:  2\n\nClasses: stable, physical, Hopf, binary_labels","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"Although 9 branches were found in total, only 3 remain physical (real-valued). Let us visualise the amplitudes corresponding to the two harmonics, sqrtU_1^2 + V_1^2 and sqrtU_2^2 + V_2^2 :","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"plot_1D_solutions(solutions, x=\"ω\", y=\"sqrt(u1^2 + v1^2)\")\nplot_1D_solutions(solutions, x=\"ω\", y=\"sqrt(u2^2 + v2^2)\")","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"(Image: fig3)","category":"page"},{"location":"examples/single_Duffing/","page":"Introduction: the Duffing oscillator","title":"Introduction: the Duffing oscillator","text":"The contributions of omega and 3omega are now comparable and the system shows some fairly complex behaviour! This demonstrates how an exact solution within an extended Fourier subspace [Eq. (3)] goes beyond a perturbative treatment.","category":"page"},{"location":"examples/single_parametron_1D/#parametron","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"","category":"section"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"One of the most famous effects displaced by nonlinear oscillators is parametric resonance, where the frequency of the linear resonator is modulated in time  Phys. Rev. E 94, 022201 (2016). In the following we analyse this system, governed by the equations","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"ddotx(t)+gammadotx(t)+Omega^2(1-lambdacos(2omega t + psi))x + alpha x^3 +eta x^2 dotx+F_textd(t)=0","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"where for completeness we also considered an external drive term F_textd(t)=Fcos(omega t + theta) and a nonlinear damping term eta x^2 dotx","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"To implement this system in Harmonic Balance, we first import the library ","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"using HarmonicBalance.jl","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"Subsequently, we type define parameters in the problem and the oscillating amplitude function x(t) using the variables macro from Symbolics.jl ","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"@variables Ω,γ,λ,F, x,θ,η,α, ω, ψ, x(t), t\n\nnatural_equation =  d(d(x,t),t) + γ*d(x,t) + Ω^2*(1-λ*cos(2*ω*t+ψ))*x + α * x^3 + η *d(x,t) * x^2\nforces =  F*cos(ω*t+θ)\ndEOM = HarmonicBalance.DifferentialEquation(natural_equation + forces, x)","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"Note that an equation of the form  m ddotx+m omega_0^2left(1-lambda cos (2omega t+psi)right) x+gamma dotx+alpha x^3+eta x^2 dotx=F cos omega t can be brought to dimensionless form after a redefinition a scaling transformation described in Phys. Rev. E 94, 022201 (2016).","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"We are interested in studying the response of the oscillator to parametric driving and forcing. In particular, we focus on the first parametric resonance of the system, i.e. operating around twice the bare frequency of the undriven oscillator omega while the frequency of the external drive is also omega. For this purpose, we consider a harmonic ansatz which contains a single frequency: x(t)approx ucos(omega t)+vsin(omega t).   In HarmonicBalance, we can do this via add_harmonic command:","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"HarmonicBalance.add_harmonic!(dEOM, x, ω);","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"and applying the perturbative averaging method, which replaces the full time dependent equation by time independent averaged equations of motion. This can be simply done by writing","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"@time averagedEOM = HarmonicBalance.get_harmonic_equations(dEOM)","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"The output of these equations are consistent with the result found in the literature. Now are are interested in the linear response spectrum, which we can obtain from the solutions to the averaged equations (rotating frame) as a function of the external drive, after fixing all other parameters in the system. A call to get_steady_states then retrieves all steadystates found allong the sweep employing the homotopy continuation method, which occurs in a complex space (see the niceHomotopyContinuation.jl docs)","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"fixed_parameters = (Ω => 1.0,γ => 1E-2, λ => 5E-2, F => 1E-3,  α => 1.,  η=>0.3, θ => 0, ψ => 0)\nsweep = ω => LinRange(0.9, 1.1, 100)\n\nsoln = HarmonicBalance.get_steady_states(averagedEOM, sweep, fixed_parameters, random_warmup=true, threading=false)","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"In the last line we set the option random_warmup=true as a means to initiate the homotopy in a generalised version of the harmonic equations, where parameters become random complex numbers. A parameter homotopy then follows to each of the frequency values omega in sweep. This offers speed-up, but requires to be tested in each scenario againts the option random_warmup=false, which initializes the homotopy in a total degree system (maximum number of roots), but needs to track significantly more homotopy paths and there is slower. The threading option enables parallel tracking of homotopy paths, and it's set to false simply because we are using a single core computer for now.","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"After solving the system, we can save the full output of the simulation and the model (e.g. symbolic expressions for the harmonic equations) into a file","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"HarmonicBalance.save(\"parametron_result.jld2\", soln);","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"During the execution of get_steady_states, different solution branches are classified by their proximity in complex space, with subsequent filtering of real (physically accceptable solutions). In addition, the stability properties of each steady state is assesed from the eigenvalues of the Jacobian matrix. All this information can be succintly represented in a 1D plot via","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"save_dict = HarmonicBalance.plot_1D_solutions(soln, x=\"ω\", y=\"sqrt(u1^2 + v1^2)\", plot_only=[\"physical\"]);","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"where save_dict is a dictionary that contains the plotted data and can be also exported if desired by setting a filename through the argument filename in plot_1D_solutions. A call to the above function produces the following figure","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"(Image: fig1)","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"The user can also can also introduce custom clases based on parameter conditions. Here we show some arbitrary example","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"plt = HarmonicBalance.plot_1D_solutions(soln, x=\"ω\", y=\"sqrt(u1^2 + v1^2)\", marker_classification=\"ω^15 * sqrt(u1^2 + v1^2) < 0.1\")","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"producing ","category":"page"},{"location":"examples/single_parametron_1D/","page":"Parametrically driven Duffing resonator","title":"Parametrically driven Duffing resonator","text":"(Image: fig2)","category":"page"},{"location":"manual/linear_response/#linresp_man","page":"Linear response","title":"Linear response","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"This module currently has two goals. One is calculating the Jacobian, used to obtain stability and approximate (but inexpensive) the linear response of steady states. The other is calculating the full response matrix as a function of frequency; this is more accurate but more expensive. ","category":"page"},{"location":"manual/linear_response/#Stability-and-response-from-the-Jacobian","page":"Linear response","title":"Stability and response from the Jacobian","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"The simplest way to extract the linear response of a steady state is to evaluate the Jacobian of the harmonic equations. Each of its eigenvalues lambda describes a Lorentzian peak in the response; textRelambda gives its center and textImlambda its width. Transforming the harmonic variables into the non-rotating frame (that is, inverting the harmonic ansatz) then gives the response as it would be observed in an experiment.","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"The advantage of this method is that for a given parameter set, only one matrix diagonalization is needed to fully describe the response spectrum. However, the method is inaccurate for response frequencies far from the frequencies used in the harmonic ansatz (it relies on the response oscillating slowly in the rotating frame). ","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"The Jacobian is also used to evaluate stability of the solutions.","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"HarmonicBalance.get_Jacobian\nHarmonicBalance.plot_jacobian_spectrum","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.get_Jacobian","page":"Linear response","title":"HarmonicBalance.LinearResponse.get_Jacobian","text":"get_Jacobian(eom)\n\n\nObtain the symbolic Jacobian matrix of eom (either a HarmonicEquation or a DifferentialEquation).\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.plot_jacobian_spectrum","page":"Linear response","title":"HarmonicBalance.LinearResponse.plot_jacobian_spectrum","text":"plot_jacobian_spectrum(res::Result,\n nat_var::Num;\n  Ω_range,\n   branch::Int,\n    y_offset::String=\"0.0\",\n      x_scale=1.0,\n       y_scale=1.0,\n        logscale=false)\n\nMake a 1D plot of the response spectrum of res for the natural variable nat_var. Performs one matrix diagonalization for each element of Ω_range. This method is faster than plot_response but results in errors where the noise frequency is far from the frequency of the harmonic variables.\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"Behind the scenes, the spectra are stored using the dedicated structs Lorentzian and JacobianSpectrum.","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"HarmonicBalance.LinearResponse.JacobianSpectrum\nHarmonicBalance.LinearResponse.Lorentzian","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.JacobianSpectrum","page":"Linear response","title":"HarmonicBalance.LinearResponse.JacobianSpectrum","text":"mutable struct JacobianSpectrum\n\nHolds a set of Lorentzian objects belonging to a variable.\n\nFields\n\npeaks::Vector{HarmonicBalance.LinearResponse.Lorentzian}\n\nConstructor\n\nJacobianSpectrum(res::Result; index::Int, branch::Int)\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.Lorentzian","page":"Linear response","title":"HarmonicBalance.LinearResponse.Lorentzian","text":"struct Lorentzian\n\nHolds the three parameters of a Lorentzian peak, defined as A / sqrt((ω-ω0)² + Γ²).\n\nFields\n\nω0::Float64\nΓ::Float64\nA::Float64\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_response/#The-full-response-matrix","page":"Linear response","title":"The full response matrix","text":"","category":"section"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"To recover the response spectra accurately. Unlike for the Jacobian, here we must evaluate in every point. ","category":"page"},{"location":"manual/linear_response/","page":"Linear response","title":"Linear response","text":"HarmonicBalance.LinearResponse.ResponseMatrix\nHarmonicBalance.get_response\nHarmonicBalance.LinearResponse.get_response_matrix\nHarmonicBalance.plot_response","category":"page"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.ResponseMatrix","page":"Linear response","title":"HarmonicBalance.LinearResponse.ResponseMatrix","text":"struct ResponseMatrix\n\nHolds the compiled response matrix of a system.\n\nFields\n\nmatrix::Matrix{Function}\nThe response matrix (compiled).\nsymbols::Vector{Symbolics.Num}\nAny symbolic variables in matrix to be substituted at evaluation.\nωs::Vector{Symbolics.Num}\nThe frequencies of the harmonic variables underlying matrix. These are needed to transform the harmonic variables to the non-rotating frame.\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.get_response","page":"Linear response","title":"HarmonicBalance.LinearResponse.get_response","text":"get_response(rmat::HarmonicBalance.LinearResponse.ResponseMatrix, s::Dict{Symbolics.Num, ComplexF64}, Ω) -> Any\n\n\nFor rmat and a solution dictionary s, calculate the total response to a perturbative force at frequency Ω.\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.get_response_matrix","page":"Linear response","title":"HarmonicBalance.LinearResponse.get_response_matrix","text":"get_response_matrix(diff_eq::DifferentialEquation, freq::Num; order=2)\n\nObtain the symbolic linear response matrix of a diff_eq corresponding to a perturbation frequency freq. This routine cannot accept a HarmonicEquation since there, some time-derivatives are already dropped. order denotes the highest differential order to be considered.\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_response/#HarmonicBalance.LinearResponse.plot_response","page":"Linear response","title":"HarmonicBalance.LinearResponse.plot_response","text":"plot_response(res::Result, Ω_range; branch, logscale)\n\n\nPlot the linear response of a solution branch of res for the frequencies Ω_range.\n\nThis method takes n^2 matrix inversions for n elements of Ω_range. It therefore takes longer than plot_jacobian_spectrum (which is (O(n))) but is also valid far from resonance. \n\n\n\n\n\n","category":"function"},{"location":"background/harmonic_balance/#intro_hb","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"","category":"section"},{"location":"background/harmonic_balance/#prelude","page":"The method of harmonic balance","title":"Frequency conversion in oscillating nonlinear systems","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"HarmonicBalance.jl focuses on harmonically-driven nonlinear systems, i.e., dynamical systems governed by equations of motion where all explicitly time-dependent terms are harmonic. Let us take a general nonlinear system of N second-order ODEs with real variables x_i(t), i = 12cdotsN and time t as the independent variable,","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqode\n  ddotmathbfx(t)+ mathbfF(mathbfx(t) t)=0\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"The vector mathbfx(t) = (x_1(t)  x_N(t))^text T fully describes the state of the system.  Physically, mathbfx(t) encompasses the amplitudes of either point-like or collective oscillators (e.g., mechanical resonators, voltage oscillations in RLC circuits, an oscillating electrical dipole moment, or standing modes of an optical cavity). ","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"As the simplest example, let us first solve the harmonic oscillator in frequency space. The equation of motion is","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\nddotx(t) + gamma dotx(t) + omega_0^2 x(t) = F cos(omega_d t)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"where gamma is the damping coefficient and omega_0 the natural frequency. Fourier-transforming both sides of this equation gives","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n(omega_0^2 - omega^2 + i omega gamma) tildex(omega) = fracF2 left delta(omega + omega_d) + delta(omega - omega_d) right \nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Evidently, tildex(omega) is only nonvanishing for omega = pm omega_d. The system thus responds at the driving frequency only - the behaviour can be captured by a single harmonic. This illustrates the general point that linear systems are exactly solvable by transforming to Fourier space, where the equations are diagonal.","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"The situation becomes more complex if nonlinear terms are present, as these cause frequency conversion. Suppose we add a quadratic nonlinearity beta x^2(t) to the equations of motion; an attempt to Fourier-transform gives","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqduffingFT\n    textFTx^2(omega) =  int x^2(t) e^-iomega t  dt = int_-infty^+infty tildex(omega)tildex(omega) delta(omega+omega-omega)  domega  domega \nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"which couples all harmonics omega omega omega such that omega + omega + omega = 0. To lowest order, this means the induced motion at the drive frequency generates a higher harmonic, omega_d rightarrow 2omega_d. To higher orders however, the frequency conversion propagates through the spectrum, coupling an infinite number of harmonics. The system is not solvable in Fourier space anymore!","category":"page"},{"location":"background/harmonic_balance/#Harmonic-ansatz-and-harmonic-equations","page":"The method of harmonic balance","title":"Harmonic ansatz & harmonic equations","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Even though we need an infinity of Fourier components to describe our system exactly, some components are more important than others. The strategy of harmonic balance is to describe the motion of any variable x_i(t) in a truncated Fourier space","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\nx_i(t) = sum_j=1^M_i u_ij  (T)  cos(omega_ij t)+ v_ij (T) sin(omega_ij t) \nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Within this space, the system is described by a finite-dimensional vector","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqharmansatz\nmathbfu(T) = (u_11(T) v_11(T) ldots u_N M_N(T) v_N M_N(T))\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Under the assumption that mathbfu(T) evolves at much slower timescales than the oscillatory terms omega_ij t, we may neglect all of its higher order time derivatives. Notice that once ansatz \\eqref{eq:harmansatz} is used in Eq. \\eqref{eq:ode}, all terms become oscillatory - each prefactor of cos(omega_ij t) and sin(omega_ij t) thus generates a separate equation. Collecting these, we obtain a 1st order nonlinear ODEs,","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqharmeq\nfracdmathbfu(T)dT  = barmathbfF (mathbfu)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"which we call the harmonic equations. The main purpose of HarmonicBalance.jl is to obtain and solve them. We are primarily interested in steady states mathbfu_0 defined by barmathbfF(mathbfu_0) = 0.","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"The process of obtaining the harmonic equations is best shown on an example.","category":"page"},{"location":"background/harmonic_balance/#Duffing_harmeq","page":"The method of harmonic balance","title":"Example: the Duffing oscillator","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Here, we derive the harmonic equations for a single Duffing resonator, governed by the equation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation labeleqduffing\n    ddotx(t) + omega_0^2 x(t) + alpha x^3(t) = F cos(omega_d t + theta)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"As explained in above, for a periodic driving at frequency omega_d and a weak nonlinearity alpha, we expect the response at frequency omega_d to dominate, followed by a response at 3omega_d due to frequency conversion.","category":"page"},{"location":"background/harmonic_balance/#Single-frequency-ansatz","page":"The method of harmonic balance","title":"Single-frequency ansatz","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"We first attempt to describe the steady states of Eq. \\eqref{eq:duffing} using only one harmonic, omega_d. The starting point is the harmonic ansatz for x","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n\tx(t) = u(T) cos(omega_d t) + v(T) sin(omega_d t)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"with the harmonic variables u and v. The slow time T is, for now, equivalent to t. Substituting this ansatz into Eq. \\eqref{eq:duffing} results in","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginalign labeleqansatz1\n\tleftddotu + 2 omega_d dotv + u left(omega_0^2 - omega_d^2 right) +  frac3 alpha left(u^3 + uv^2right)4 + F costhetaright cos(omega_d t) \n\t+ leftddotv - 2 omega_d dotu + v left(omega_0^2 - omega_d^2 right)  +frac3 alpha left(v^3 + u^2 vright)4 - F sinthetaright sin(omega_d t) nonumber \n\t+ fracalpha left(u^3 - 3 u v^2right)4 cos(3 omega_d t) +  fracalpha left(3u^2 v - v^3right)4 sin(3 omega_d t) = 0 nonumber\nendalign","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"We see that the x^3 term has generated terms that oscillate at 3omega_d, describing the process of frequency upconversion. We now Fourier-transform both sides of Eq. \\eqref{eq:ansatz1} with respect to omega_d to obtain the harmonic equations. This process is equivalent to extracting the respective coefficients of cos(omega_d t) and sin(omega_d t). Here the distinction between t and T becomes important: since the evolution of u(T) and v(T) is assumed to be slow, they are treated as constant for the purpose of the Fourier transformation. Since we are interested in steady states, we drop the higher-order derivatives and rearrange the resulting equation to","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n\tfracddT beginpmatrix u  v  endpmatrix = frac18 omega_d beginpmatrix 4 v left(omega_0^2-omega_d^2 right) + 3 alpha left(v^3 + u^2 v  right) - 4 F sintheta   4 u left(omega_d^2-omega_0^2 right)  - 3 alpha left(u^3 + u v^2 right) - 4 F costheta  endpmatrix \nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"Steady states can now be found by setting the l.h.s. to zero, i.e., assuming u(T) and v(T) constant and neglecting any transient behaviour. This results in a set of 2 nonlinear polynomial equations of order 3, for which the maximum number of solutions set by Bézout's theorem is 3^2=9. Depending on the parameters, the number of real solutions is known to be between 1 and 3.","category":"page"},{"location":"background/harmonic_balance/#Sidenote:-perturbative-approach","page":"The method of harmonic balance","title":"Sidenote: perturbative approach","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"The steady states describe a response that may be recast as x_0(t) = X_0 cos(omega_d t + phi), where X_0=sqrtu^2+v^2 and phi=-textatan(vu). Frequency conversion from omega_d to 3 omega_d can be found by setting x(t) equiv x_0(t) + delta x(t) with delta x(t)llx_0(t) and expanding Eq. \\eqref{eq:duffing} to first-order in delta x(t). The resulting equation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n    delta ddotx(t) + leftomega_0^2 + frac3 alpha X_0^24 rightdelta x(t) = - fracalpha X_0^34 cos(3 omega_d t + 3 phi)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"describes a simple harmonic oscillator, which is exactly soluble. Correspondingly, a response of delta x(t) at frequency 3 omega_d is observed. Since this response is obtained 'on top of' each steady state of Eq. \\eqref{eq:duffing}, no previously-unknown solutions are generated in the process.","category":"page"},{"location":"background/harmonic_balance/#Two-frequency-ansatz","page":"The method of harmonic balance","title":"Two-frequency ansatz","text":"","category":"section"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"An approach in the spirit of harmonic balance is to use both harmonics omega_d and 3 omega_d on the same footing, i.e., to insert the ansatz","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"beginequation\n\tx(t) = u_1(T) cos(omega_d t) + v_1(T) sin(omega_d t) + u_2(T) cos(3 omega_d t) + v_2(T) sin(3omega_d t)\nendequation","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"with u_1 u_2 v_1 v_2 being the harmonic variables. As before we substitute the ansatz into Eq. \\eqref{eq:duffing}, drop second derivatives with respect to T and Fourier-transform both sides. Now, the respective coefficients correspond to cos(omega_d t), sin(omega_d t), cos(3 omega_d t) and sin(3omega_d t). Rearranging, we obtain","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"\tbeginalign\n\tbeginsplit\n\tfracdu_1dT =  frac12omega_d left left(omega_0^2 - omega_d^2 right) v_1 + frac3alpha4 left( v_1^3 + u_1^2 v_1 + u_1^2 v_2 - v_1^2 v_2 + 2 u_2^2 v_1 + 2 v_2^2 v_1 - 2 u_1 u_2 v_1right)  + F sintheta right\n\t\n\tfracdv_1dT = frac12omega_d left left(omega_d^2 - omega_0^2 right) u_1 - frac3 alpha4 left( u_1^3 + u_1^2 u_2 + v_1^2 u_1 - v_1^2 u_2+ 2 u_2^2 u_1 + 2 v_2^2 u_1  + 2 u_1 v_1 v_2right) - F costheta right\n\t\n\tfracd u_2dT = frac16 omega_d left left(omega_0^2 - 9omega_d^2 right) v_2 + fracalpha4 left( - v_1^3 + 3 v_2^3 + 3 u_1^2 v_1 + 6 u_1^2 v_2 + 3 u_2^2 v_2 + 6 v_1^2 v_2right) right\n\t\n\tfracdv_2dT = frac16 omega_d left left(9omega_d^2 - omega_0^2right) u_2 - fracalpha4 left( u_1^3 + 3 u_2^3 + 6 u_1^2 u_2 - 3 v_1^2 u_1 + 3 v_2^2 u_2 + 6 v_1^2 u_2right) right \n\tendsplit\n\tendalign","category":"page"},{"location":"background/harmonic_balance/","page":"The method of harmonic balance","title":"The method of harmonic balance","text":"In contrast to the single-frequency ansatz [Eqs. \\eqref{eq:ansatz1}],  we now have 4 equations of order 3, allowing up to 3^4=81 solutions (the number of unique real ones is again generally far smaller). The larger number of solutions is explained by higher harmonics which cannot be captured perturbatively by the single-frequency ansatz. In particular, those where the 3 omega_d component is significant. Such solutions appear, e.g., for omega_d approx omega_0  3 where the generated 3 omega_d harmonic is close to the natural resonant frequency. See the examples for numerical results.","category":"page"},{"location":"#HarmonicBalance.jl","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"HarmonicBalance.jl is a Julia package for solving nonlinear differential equations using the method of harmonic balance.","category":"page"},{"location":"#Installation","page":"HarmonicBalance.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"To install HarmonicBalance.jl, you can use the github repo https://github.com/NonlinearOscillations/HarmonicBalance.jl or the Julia package manager,","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"using Pkg\nPkg.add(\"HarmonicBalance\")","category":"page"},{"location":"#Citation","page":"HarmonicBalance.jl","title":"Citation","text":"","category":"section"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"If you use HarmonicBalance.jl in your project, we kindly ask you to cite this paper:","category":"page"},{"location":"","page":"HarmonicBalance.jl","title":"HarmonicBalance.jl","text":"@misc{10.48550/arXiv.2202.00571,\n    title={HarmonicBalance.jl: A Julia suite for nonlinear dynamics using harmonic balance}, \n    author={Košata, Jan and del Pino, Javier and Heugel, Toni and Zilberberg, Oded},\n    year={2022},\n    doi={10.48550/arXiv.2202.00571},\n    howpublished={\\href{https://arxiv.org/abs/2202.00571}{arXiv:2202.00571}}\n}","category":"page"}]
}
