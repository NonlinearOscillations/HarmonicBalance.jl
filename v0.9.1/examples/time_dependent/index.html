<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction: time-dependent simulations · HarmonicBalance.jl</title><meta name="title" content="Introduction: time-dependent simulations · HarmonicBalance.jl"/><meta property="og:title" content="Introduction: time-dependent simulations · HarmonicBalance.jl"/><meta property="twitter:title" content="Introduction: time-dependent simulations · HarmonicBalance.jl"/><meta name="description" content="Documentation for HarmonicBalance.jl."/><meta property="og:description" content="Documentation for HarmonicBalance.jl."/><meta property="twitter:description" content="Documentation for HarmonicBalance.jl."/><meta property="og:url" content="https://nonlinearoscillations.github.io/HarmonicBalance.jl/stable/examples/time_dependent/"/><meta property="twitter:url" content="https://nonlinearoscillations.github.io/HarmonicBalance.jl/stable/examples/time_dependent/"/><link rel="canonical" href="https://nonlinearoscillations.github.io/HarmonicBalance.jl/stable/examples/time_dependent/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../background/harmonic_balance/"><img src="../../assets/logo.png" alt="HarmonicBalance.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../background/harmonic_balance/">HarmonicBalance.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../../background/harmonic_balance/">The method of harmonic balance</a></li><li><a class="tocitem" href="../../background/stability_response/">Stability and linear response</a></li><li><a class="tocitem" href="../../background/limit_cycles/">Limit cycles</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../simple_Duffing/">Introduction: the Duffing oscillator</a></li><li><a class="tocitem" href="../linear_response/">Introduction: linear response</a></li><li class="is-active"><a class="tocitem" href>Introduction: time-dependent simulations</a><ul class="internal"><li><a class="tocitem" href="#Evolving-from-an-initial-condition"><span>Evolving from an initial condition</span></a></li><li><a class="tocitem" href="#Parameter-sweeps"><span>Parameter sweeps</span></a></li><li><a class="tocitem" href="#Limit-cycles"><span>Limit cycles</span></a></li></ul></li><li><a class="tocitem" href="../parametron/">Parametrically driven Duffing resonator: 1D and 2D plots</a></li><li><a class="tocitem" href="../limit_cycles/">Limit cycles</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/entering_eom/">Entering equations of motion</a></li><li><a class="tocitem" href="../../manual/extracting_harmonics/">Extracting harmonic equations</a></li><li><a class="tocitem" href="../../manual/solving_harmonics/">Solving harmonic equations</a></li><li><a class="tocitem" href="../../manual/Krylov-Bogoliubov_method/">Krylov-Bogoliubov Averaging Method</a></li><li><a class="tocitem" href="../../manual/plotting/">Analysis and plotting</a></li><li><a class="tocitem" href="../../manual/time_dependent/">Time evolution</a></li><li><a class="tocitem" href="../../manual/linear_response/">Linear response (WIP)</a></li><li><a class="tocitem" href="../../manual/saving/">Saving and loading</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Introduction: time-dependent simulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction: time-dependent simulations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NonlinearOscillations/HarmonicBalance.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NonlinearOscillations/HarmonicBalance.jl/blob/master/docs/src/examples/time_dependent.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction:-time-dependent-simulations"><a class="docs-heading-anchor" href="#Introduction:-time-dependent-simulations">Introduction: time-dependent simulations</a><a id="Introduction:-time-dependent-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction:-time-dependent-simulations" title="Permalink"></a></h1><p>Most of HarmonicBalance.jl is focused on finding and analysing the steady states. Such states contain no information about transient behaviour, which is crucial to answer the following.</p><ul><li>Given an initial condition, which steady state does the system evolve into?</li><li>How does the system behave if its parameters are varied in time?</li></ul><p>It is straightforward to evolve the full equation of motion using an ODE solver. However, tracking oscillatory behaviour is computationally expensive.</p><p>In the <a href="../../background/harmonic_balance/#intro_hb">background</a>, we showed that nonlinear driven systems may be reduced to harmonic equations</p><p class="math-container">\[\begin{equation} \label{eq:harmeq}
\frac{d\mathbf{u}(T)}{dT}  = \bar{\mathbf{F}} (\mathbf{u})\,,
\end{equation}\]</p><p>As long as the chosen harmonics constituting <span>$\mathbf{u}(T)$</span> capture the system&#39;s behaviour, we may numerically evolve  Eq. \eqref{eq:harmeq} instead of the full problem. Since the components of <span>$\mathbf{u}(T)$</span> only vary very slowly (and are constant in a steady state), this is usually <em>vastly</em> more efficient than evolving the full problem.</p><p>Here we primarily demonstrate on the <a href="../parametron/#parametron">parametrically driven oscillator</a>. The relevant notebooks may be found <a href="https://github.com/NonlinearOscillations/HarmonicBalance-notebooks">in the example repo</a>.</p><p>We start by defining our system.</p><pre><code class="language-julia hljs">using HarmonicBalance
@variables ω0, γ, λ, F, x, θ, η, α, ω, t, x(t)

eq =  d(d(x,t),t) + γ*d(x,t) + ω0^2*(1-λ*cos(2*ω*t))*x + α*x^3 + η*d(x,t)*x^2 ~ F*cos(ω*t+θ)

diff_eq = DifferentialEquation(eq, x)
add_harmonic!(diff_eq, x, ω); # single-frequency ansatz

harmonic_eq = get_harmonic_equations(diff_eq);</code></pre><pre><code class="nohighlight hljs">A set of 2 harmonic equations
Variables: u1(T), v1(T)
...</code></pre><p>The object <code>harmonic_eq</code> encodes Eq. \eqref{eq:harmeq}.</p><p>We now wish to parse this input into <a href="https://diffeq.sciml.ai/stable/">OrdinaryDiffEq.jl</a> and use its powerful ODE solvers. The desired object here is <code>OrdinaryDiffEq.ODEProblem</code>, which is then fed into <code>OrdinaryDiffEq.solve</code>.</p><h2 id="Evolving-from-an-initial-condition"><a class="docs-heading-anchor" href="#Evolving-from-an-initial-condition">Evolving from an initial condition</a><a id="Evolving-from-an-initial-condition-1"></a><a class="docs-heading-anchor-permalink" href="#Evolving-from-an-initial-condition" title="Permalink"></a></h2><p>Given <span>$\mathbf{u}(T_0)$</span>, what is <span>$\mathbf{u}(T)$</span> at future times?</p><p>For constant parameters, a <a href="../../manual/extracting_harmonics/#HarmonicBalance.HarmonicEquation"><code>HarmonicEquation</code></a> object can be fed into the constructor of <a href="../../manual/time_dependent/#SciMLBase.ODEProblem-Tuple{HarmonicEquation, Any}"><code>ODEProblem</code></a>. The syntax is similar to DifferentialEquations.jl :</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
x0 = [0.0; 0.] # initial condition
fixed = (ω0 =&gt; 1.0,γ =&gt; 1E-2, λ =&gt; 5E-2, F =&gt; 1E-3,  α =&gt; 1., η=&gt;0.3, θ =&gt; 0, ω=&gt;1.) # parameter values

ode_problem = ODEProblem(harmonic_eq, fixed, x0 = x0, timespan = (0,1000))</code></pre><pre><code class="nohighlight hljs">ODEProblem with uType Vector{Float64} and tType Int64. In-place: true
timespan: (0, 1000)
u0: 2-element Vector{Float64}:
 0.0
 0.0</code></pre><p>OrdinaryDiffEq.jl takes it from here - we only need to use <code>solve</code>.</p><pre><code class="language-julia hljs">time_evo = solve(ode_problem, saveat=1.);
plot(time_evo, [&quot;u1&quot;, &quot;v1&quot;], harmonic_eq)</code></pre><p>Running the above code with <code>x0 = [0., 0.]</code> and <code>x0 = [0.2, 0.2]</code> gives the plots</p><img style="display: block; margin: 0 auto;" src="../../assets/time_dependent/evo_to_steady.png" alignment="center" \><p>⠀</p><p>Let us compare this to the steady state diagram.</p><pre><code class="language-julia hljs">varied = ω =&gt; range(0.9, 1.1, 100)
result = get_steady_states(harmonic_eq, varied, fixed)
plot(result, &quot;sqrt(u1^2 + v1^2)&quot;)</code></pre><img style="display: block; margin: 0 auto;" src="../../assets/time_dependent/steady.png" alignment="center" \><p>⠀</p><p>Clearly when evolving from <code>x0 = [0.,0.]</code>, the system ends up in the low-amplitude branch 2. With <code>x0 = [0.2, 0.2]</code>, the system ends up in branch 3.</p><h2 id="Parameter-sweeps"><a class="docs-heading-anchor" href="#Parameter-sweeps">Parameter sweeps</a><a id="Parameter-sweeps-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-sweeps" title="Permalink"></a></h2><p>Experimentally, the primary means of exploring the steady state landscape is an adiabatic sweep one or more of the system parameters. This takes the system along a solution branch. If this branch disappears or becomes unstable, a jump occurs.</p><p>The object <a href="../../manual/time_dependent/#HarmonicBalance.ParameterSweep"><code>ParameterSweep</code></a> specifies a sweep, which is then used as an optional <code>sweep</code> keyword in the <code>ODEProblem</code> constructor.</p><pre><code class="language-julia hljs">sweep = ParameterSweep(ω =&gt; (0.9,1.1), (0, 2E4))</code></pre><p>The sweep linearly interpolates between <span>$\omega = 0.9$</span> at time 0 and <span>$\omega  = 1.1$</span> at time 2e4. For earlier/later times, <span>$\omega$</span> is constant.</p><p>Let us now define a new <code>ODEProblem</code> which incorporates <code>sweep</code> and again use <code>solve</code>:</p><pre><code class="language-julia hljs">ode_problem = ODEProblem(harmonic_eq, fixed, sweep=sweep, x0=[0.1;0.0], timespan=(0, 2E4))
time_evo = solve(ode_problem, saveat=100)
plot(time_evo, &quot;sqrt(u1^2 + v1^2)&quot;, harmonic_eq)</code></pre><img style="display: block; margin: 0 auto;" src="../../assets/time_dependent/sweep_omega.png" alignment="center" \><p>⠀ We see the system first evolves from the initial condition towards the low-amplitude steady state. The amplitude increases as the sweep proceeds, with a jump occurring around <span>$\omega = 1.08$</span> (i.e., time 18000).</p><p>Successive sweeps can be combined,</p><pre><code class="language-julia hljs">sweep1 = ParameterSweep(ω =&gt; [0.95, 1.0], (0, 2E4))
sweep2 = ParameterSweep(λ =&gt; [0.05, 0.01], (2E4, 4E4))
sweep = sweep1 + sweep2</code></pre><p>multiple parameters can be swept simultaneously,</p><pre><code class="language-julia hljs">sweep = ParameterSweep([ω =&gt; [0.95;1.0], λ =&gt; [5E-2;1E-2]], (0, 2E4))</code></pre><p>and custom sweep functions may be used.</p><pre><code class="language-julia hljs">ωfunc(t) = cos(t)
sweep = ParameterSweep(ω =&gt; ωfunc)</code></pre><p>Either of the above can be fed into <code>ODEProblem</code> and simulated. See <a href="https://github.com/NonlinearOscillations/HarmonicBalance-notebooks">here</a> for more examples.</p><h2 id="Limit-cycles"><a class="docs-heading-anchor" href="#Limit-cycles">Limit cycles</a><a id="Limit-cycles-1"></a><a class="docs-heading-anchor-permalink" href="#Limit-cycles" title="Permalink"></a></h2><p>So far, we have largely focused on finding and analysing steady states, i.e., fixed points of the harmonic equations, which satisfy</p><p class="math-container">\[\begin{equation} \label{eq:harmeqfull}
\frac{d\mathbf{u}(T)}{dT}  = \bar{\mathbf{F}} (\mathbf{u}) = 0\,.
\end{equation}\]</p><p>Fixed points are however merely a subset of possible solutions of Eq. \eqref{eq:harmeqfull} – strictly speaking, solutions where <span>$\mathbf{u}(T)$</span> remains time-dependent are allowed. These are quite unusual, since <span>$\bar{\mathbf{F}} (\mathbf{u})$</span> <a href="../../background/harmonic_balance/#intro_hb">is by construction time-independent</a> and Eq. \eqref{eq:harmeqfull} thus possesses <em>continuous time-translation symmetry</em>. The appearance of explicitly time-dependent solutions then consitutes spontaneous time-translation symmetry breaking.</p><p>Such solutions, known as <em>limit cycles</em>, typically appear as closed periodic trajectories of the harmonic variables <span>$\mathbf{u}(T)$</span>. The simplest way to numerically characterise them is a time-dependent simulation, using a steady-state diagram as a guide.</p><p>Here we reconstruct the results of <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.023526">Zambon et al., Phys Rev. A 102, 023526 (2020)</a>, where limit cycles are shown to appear in a system of two coupled nonlinear oscillators. In this problem, two oscillators <span>$x_1$</span> and <span>$x_2$</span>, have (the same) damping and Kerr nonlinearity and are linearly coupled,</p><p class="math-container">\[\begin{align}
\ddot{x}_1+ \gamma \dot{x}_1 + \omega_0^2 x_1 + \alpha x_1^3 + 2J(x_1-x_2) &amp;= F_0 \cos(\omega t) \\
\ddot{x}_2+ \gamma \dot{x}_2 + \omega_0^2 x_2 + \alpha x_2^3 + 2J(x_2-x_1) &amp;= \eta F_0 \cos(\omega t)
\end{align}\]</p><pre><code class="language-julia hljs">using HarmonicBalance
@variables γ, F, α, ω0, F0, η, ω, J, t, x(t), y(t);

diff_eq = DifferentialEquation([d(x,t,2) + γ * d(x,t) + ω0^2 * x + α*x^3+ 2*J*ω0*(x-y) - F0*cos(ω*t),
            d(y,t,2) + γ * d(y,t) + ω0^2 * y + α*y^3 + 2*J*ω0*(y-x) - η*F0*cos(ω*t)], [x,y])
</code></pre><p>The analysis of Zambon et al. uses a frame rotating at the pump frequency <span>$\omega$</span> to describe both oscillators. For us, this means we expand both modes using <span>$\omega$</span> to obtain the harmonic equations.</p><pre><code class="language-julia hljs">add_harmonic!(diff_eq, x, ω)
add_harmonic!(diff_eq, y, ω)

harmonic_eq = get_harmonic_equations(diff_eq)</code></pre><p>Solving for a range of drive amplitudes <span>$F_0$</span>,</p><pre><code class="language-julia hljs">fixed = (
    ω0 =&gt; 1.4504859, # natural frequency of separate modes (in paper&#39;s notation, ħω0 - J)
    γ =&gt; 27.4E-6,    # damping
    J =&gt; 154.1E-6,   # coupling term
    α =&gt; 3.867E-7,   # Kerr nonlinearity
    ω =&gt; 1.4507941,  # pump frequency, resonant with antisymmetric mode (in paper, ħω0 + J)
    η =&gt; -0.08,      # pumping leaking to site 2  (F2 = ηF1)
    F0 =&gt; 0.002       # pump amplitude (overriden in sweeps)
)
varied = F0 =&gt; LinRange(0.002, 0.03, 50)

result = get_steady_states(harmonic_eq, varied, fixed)</code></pre><pre><code class="nohighlight hljs">A steady state result for 50 parameter points

Solution branches:   9
   of which real:    3
   of which stable:  2</code></pre><p>Let us first see the steady states.</p><pre><code class="language-julia hljs">p1 = plot(result, &quot;u1^2 + v1^2&quot;, legend=false)
p2 = plot(result, &quot;u2^2 + v2^2&quot;)
plot(p1, p2)</code></pre><img style="display: block; margin: 0 auto; padding-bottom: 20px" src="../../assets/time_dependent/lc_steady.png" alignment="center"\><p>According to Zambon et al., a limit cycle solution exists around <span>$F_0 \cong 0.011$</span>, which can be accessed by a jump from branch 1 in an upwards sweep of <span>$F_0$</span>. Since a limit cycle is not a steady state of our harmonic equations, it does not appear in the diagram. We do however see that branch 1 ceases to be stable around <span>$F_0 \cong 0.010$</span>, meaning a jump should occur.</p><p>Let us try and simulate the limit cycle. We could in principle run a time-dependent simulation with a fixed value of <span>$F_0$</span>, but this would require a suitable initial condition. Instead, we will sweep <span>$F_0$</span> upwards from a low starting value. To observe the dynamics just after the jump has occurred, we follow the sweep by a time interval where the system evolves under fixed parameters.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
initial_state = result[1][1]

T = 2E6
sweep = ParameterSweep(F0 =&gt; (0.002, 0.011), (0,T))

# start from initial_state, use sweep, total time is 2*T
time_problem = ODEProblem(harmonic_eq, initial_state, sweep=sweep, timespan=(0,2*T))
time_evo = solve(time_problem, saveat=100);</code></pre><p>Inspecting the amplitude as a function of time,</p><pre><code class="language-julia hljs">plot(time_evo, &quot;sqrt(u1^2 + v1^2)&quot;, harmonic_eq)</code></pre><img style="display: block; margin: 0 auto; padding-bottom: 20px" src="../../assets/time_dependent/lc_sweep.png" alignment="center" \><p>we see that initially the sweep is adiabatic as it proceeds along the steady-state branch 1. At around <span>$T = 2E6$</span>, an instability occurs and <span>$u_1(T)$</span> starts to rapidly oscillate. At that point, the sweep is stopped. Under free time evolution, the system then settles into a limit-cycle solution where the coordinates move along closed trajectories.</p><p>By plotting the <span>$u$</span> and <span>$v$</span> variables against each other, we observe the limit cycle shapes in phase space,</p><pre><code class="language-julia hljs">p1 = plot(time_evo, [&quot;u1&quot;, &quot;v1&quot;], harmonic_eq)
p2 = plot(time_evo, [&quot;u2&quot;, &quot;v2&quot;], harmonic_eq)
plot(p1, p2)</code></pre><img style="display: block; margin: 0 auto;" src="../../assets/time_dependent/lc_uv.png" alignment="center" \></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linear_response/">« Introduction: linear response</a><a class="docs-footer-nextpage" href="../parametron/">Parametrically driven Duffing resonator: 1D and 2D plots »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 10 April 2024 11:49">Wednesday 10 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
